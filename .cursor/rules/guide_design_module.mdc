# Battle Plan v3.0: The Unified Guide Design Campaign

## 1.0 Mission Objective
To evolve our `CommandCenter` by fusing the stateful, persistent `BattlePlan` system with the speed and power of the "One-Click Conquest" workflow. The result will be a new, end-to-end campaign that is both devastatingly effective and fully integrated into our patient management system.

## 2.0 Plan of Attack

### Phase I: Purge the Heresy (Cleansing the Arsenal)
**Objective:** To remove all obsolete, local-execution tools and doctrines.

- **Task 1.1: Delete `tools/intelligent_guide_finder.py`**. Its purpose is now fulfilled and surpassed by this new doctrine.
- **Task 1.2: Delete the `tools/chopchop/` Directory**. Its methods are ancient history.
- **Task 1.3: Delete `tools/chopchop_integration.py`**. Redundant.

### Phase II: Forge the v3 Campaign Workflow (The Core Mission)
**Objective:** To build a new, flagship endpoint that represents the pinnacle of our strategy.

- **Task 2.1: Create New Endpoint: `/v3/workflow/execute_guide_design_campaign`**
  - **Action:** This new endpoint in `services/command_center/main.py` will be the heart of our new system.
  - **Input:** `{ "battle_plan_id": int }`

- **Task 2.2: Implement the "Battle Plan Kill Chain"**
  - **Action:** This workflow will execute the entire v2.0 conquest, but now within the context of a stateful `BattlePlan`.
  - **The New Logic:**
      1.  **Load Battle Plan:** Fetch the `BattlePlanModel` from the database using the provided `battle_plan_id`.
      2.  **Fetch Sequence:** Extract the `target_locus` from the battle plan and get the DNA sequence from Ensembl.
      3.  **Forge Candidates:** Execute a **live-fire** call to the `evo-service` using the `ZetaForgeClient`.
      4.  **Parallel Validation:** Unleash `asyncio` to concurrently call `ZetaOracle`, `BlastService`, and an `ImmunogenicityClient`.
      5.  **Calculate "Assassin Score" v2.0:** Compute the final score using our dynamic, weighted formula.
      6.  **Persist the Dossier:** Save the complete, ranked list of `GuideDossier` objects into the `proposed_interventions` field of the specific `BattlePlanModel` in the database.
      7.  **Update Battle Plan Status:** Update the plan's status from `pending_review` to `interventions_designed`.

- **Task 2.3: Upgrade the `BattlePlanModel`**
    - **Action:** Inspect the SQLAlchemy model in `services/command_center/models.py` and ensure the `proposed_interventions` field is robust enough to handle the rich `GuideDossier` JSON structure.

### Phase III: Refactor the Frontline UIs
- **Task 3.1: Upgrade `Intelligent_Guide_Designer.py`**
    - **New Logic:** The UI will first call `/v2/workflow/formulate_battle_plan` to create a `BattlePlan`, then immediately call our new `/v3/workflow/execute_guide_design_campaign` to get the results.
- **Task 3.2: Upgrade `Patient_Digital_Twin.py`**
    - **New Logic:** The "Design Precision Intervention" button will now trigger the new `/v3/workflow/execute_guide_design_campaign`.

## 3.0 v3.0 Critical Intelligence: Service Blueprints & Scoring
*The v2.0 technical blueprints for the individual services and the "Assassin Score" formula remain the core components of this v3.0 strategy.*

### 3.1 ZetaForge (`evo_service`)
- **Protocol:** Asynchronous job pattern.
- **v2.0 Enhancements:**
  - Implement a 5-minute timeout on polling.
  - Support webhooks for instant job completion notifications.
- **v2.0 Payload:** `{ "target_sequence": "...", "num_guides": 10, "condition": "anti-angiogenic" }`

### 3.2 ZetaOracle (`oracle`)
- **Protocol:** Synchronous request/response.
- **v2.0 Enhancements:**
  - Endpoint must support **batch requests** (an array of `params`) to reduce latency.
- **v2.0 Payload:** `{ "action": "score", "params": [{ "reference_sequence": "...", "alternate_sequence": "...", "mutation_type": "missense" }] }`

### 3.3 BLAST Service (`blast_service`)
- **Protocol:** Internal Modal call.
- **v2.0 Enhancements:**
  - **CommandCenter Logic:** Must parse BLAST XML and then use an AI model (e.g., a call to Evo2) to score the potential impact of high-priority off-targets.
  - **Method Signature:** `search(query_sequence: str, num_mismatches: int = 3, mismatch_threshold: int = 2)`
  - **Auditing:** All BLAST results must be logged.

### 3.4 Ensembl API (Context Fetch)
- **v2.0 Enhancements:**
  - CommandCenter will cache results to reduce redundant API calls.
  - Implement fallbacks to other genome browsers (e.g., UCSC).
  - Validate fetched sequence against our internal reference database.

## 4.0 Scoring Formula: The "Assassin Score" (v2.0)
- **Primary Formula:** `Assassin Score = (Efficacy * W_e) + (Safety * W_s) + (Immunogenicity * W_i)`
- **Dynamic Weights:** Weights (`W_e`, `W_s`, `W_i`) will be configurable (e.g., from a config file), with defaults of `0.5`, `0.3`, `0.2`.
- **Confidence Multiplier:** The final score for each component will be multiplied by its `confidence` value.
- **Components:**
  - **Efficacy:** `(1 - (1 / (1 + abs(zeta_score)))) * confidence`
  - **Safety:** `(1 / (1 + number_of_ai_weighted_off_targets)) * confidence`
  - **Immunogenicity:** `(1 - immunogenicity_score) * confidence`

## 4.0 TO-DO: Future Upgrades & Enhancements
- **Live Service Integration:** Build out the real `httpx` clients for the Oracle, BLAST, and Immunity services to replace the current placeholders.
- **Dynamic Scoring Weights:** Move the Assassin Score weights from hardcoded values into a configuration file for easy tuning.
- **AI-Powered BLAST Analysis:** Upgrade the BLAST result parser in the `CommandCenter` to include a call to an AI model (e.g., Evo2) to assess the functional impact of off-targets, not just their count.
