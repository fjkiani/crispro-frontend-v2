# ðŸ§¬ MODULE 02: BIOMARKER CALCULATION AGENT

**Purpose:** Calculate TMB, MSI, HRD, and IO eligibility from patient mutations  
**Priority:** ðŸ”´ CRITICAL | **Dependencies:** 01_DATA_EXTRACTION | **Consumers:** 03, 04, 05, 07

---

## ðŸŽ¯ MISSION

Build a biomarker calculation agent that can:
1. Calculate TMB from mutation list (validated r=0.933)
2. Detect MSI status from dMMR gene mutations
3. Infer HRD status from DNA repair gene mutations
4. Determine IO eligibility (TMB-H OR MSI-H)
5. Provide validation provenance for all calculations

---

## ðŸ“Š VALIDATED CAPABILITIES (USE THESE)

### TMB Calculation - ALREADY VALIDATED âœ…

**Location:** `scripts/data_acquisition/utils/tmb_calculator.py`

**Validation Metrics:**
| Metric | Value | Ground Truth |
|--------|-------|--------------|
| Pearson r | 0.933 | TCGA Pan-Immune |
| Classification Accuracy | 95.4% | n=1,895 patients |
| Sensitivity | 96.0% | TMB-H detection |
| Specificity | 95.2% | TMB-L detection |

**Key Code:**
```python
# From scripts/data_acquisition/utils/tmb_calculator.py
TCGA_EXOME_SIZE_MB = 38.0
TMB_HIGH_THRESHOLD = 10.0  # mutations per megabase

NONSYNONYMOUS_CLASSIFICATIONS = {
    'Missense_Mutation', 'Nonsense_Mutation', 'Frame_Shift_Del',
    'Frame_Shift_Ins', 'In_Frame_Del', 'In_Frame_Ins',
    'Splice_Site', 'Translation_Start_Site', 'Nonstop_Mutation'
}

def count_nonsynonymous_mutations(mutations: List[Dict]) -> int:
    """Count nonsynonymous mutations."""
    count = 0
    for mut in mutations:
        classification = mut.get("variant_classification", "").strip()
        protein_change = mut.get("hgvs_p", "") or mut.get("protein_change", "")
        
        if classification in NONSYNONYMOUS_CLASSIFICATIONS:
            count += 1
        elif protein_change and classification.upper() in ["SNP", "DEL", "INS"]:
            count += 1
    
    return count

def calculate_tmb(mutations: List[Dict], exome_size_mb: float = TCGA_EXOME_SIZE_MB) -> float:
    """Calculate TMB as mutations per megabase."""
    nonsynonymous_count = count_nonsynonymous_mutations(mutations)
    return nonsynonymous_count / exome_size_mb
```

---

## ðŸ“¥ INPUTS

### From PatientProfile (Module 01)

```python
@dataclass
class PatientProfile:
    patient_id: str
    disease: str
    mutations: List[Mutation]
    # ... other fields
```

---

## ðŸ“¤ OUTPUTS

### BiomarkerProfile Schema

```python
from dataclasses import dataclass
from typing import Optional, Dict, List
from enum import Enum

class TMBClassification(Enum):
    TMB_HIGH = "TMB-H"
    TMB_LOW = "TMB-L"
    UNKNOWN = "unknown"

class MSIStatus(Enum):
    MSI_HIGH = "MSI-H"
    MSI_LOW = "MSI-L"
    MSS = "MSS"
    UNKNOWN = "unknown"

class HRDStatus(Enum):
    HRD_POSITIVE = "HRD+"
    HRD_NEGATIVE = "HRD-"
    HRD_INFERRED = "HRD-INFERRED"
    UNKNOWN = "unknown"

@dataclass
class TMBResult:
    value: float                        # Mutations per Mb
    classification: TMBClassification
    threshold_used: float               # e.g., 10.0
    mutation_count: int                 # Total nonsynonymous
    exome_size_mb: float               # e.g., 38.0
    validation: Dict[str, any]         # Provenance

@dataclass
class MSIResult:
    status: MSIStatus
    dmmr_genes_mutated: List[str]      # e.g., ["MLH1", "MSH2"]
    dmmr_genes_checked: List[str]      # All genes checked
    method: str                         # "mutation_based" or "assay"
    confidence: float                   # 0.0 - 1.0

@dataclass
class HRDResult:
    status: HRDStatus
    score: Optional[float]              # If Myriad score available
    mechanism: Optional[str]            # e.g., "BRCA1_LOSS", "MBD4_BER"
    genes_mutated: List[str]            # HRR/BER genes mutated
    genes_checked: List[str]            # All genes checked
    confidence: float

@dataclass
class BiomarkerProfile:
    patient_id: str
    tmb: TMBResult
    msi: MSIResult
    hrd: HRDResult
    io_eligible: bool                   # TMB-H OR MSI-H
    io_eligibility_reason: str          # "TMB-H (12.3 mut/Mb)"
    parp_eligible: bool                 # HRD+ or BRCA mutant
    parp_eligibility_reason: str
    calculation_timestamp: datetime
    provenance: Dict[str, any]          # Full audit trail
```

---

## ðŸ—ï¸ IMPLEMENTATION

### File Structure

```
api/services/biomarkers/
â”œâ”€â”€ __init__.py
â”œâ”€â”€ biomarker_agent.py          # Main agent
â”œâ”€â”€ tmb_calculator.py           # TMB logic (port from validated)
â”œâ”€â”€ msi_detector.py             # MSI detection
â”œâ”€â”€ hrd_inferrer.py             # HRD inference
â”œâ”€â”€ io_eligibility.py           # IO eligibility determination
â”œâ”€â”€ constants.py                # Gene lists, thresholds
â””â”€â”€ tests/
    â”œâ”€â”€ test_tmb.py
    â”œâ”€â”€ test_msi.py
    â”œâ”€â”€ test_hrd.py
    â””â”€â”€ test_io_eligibility.py
```

### Core Agent Implementation

```python
# api/services/biomarkers/biomarker_agent.py

from typing import List
from datetime import datetime
import logging

from .tmb_calculator import TMBCalculator
from .msi_detector import MSIDetector
from .hrd_inferrer import HRDInferrer
from .io_eligibility import IOEligibilityChecker
from ..models import PatientProfile, BiomarkerProfile

logger = logging.getLogger(__name__)

class BiomarkerAgent:
    """
    Calculate all biomarkers from patient mutation data.
    
    Capabilities:
    - TMB (validated r=0.933 vs TCGA)
    - MSI (dMMR gene-based detection)
    - HRD (HRR/BER gene inference)
    - IO eligibility (TMB-H OR MSI-H)
    """
    
    def __init__(self):
        self.tmb_calculator = TMBCalculator()
        self.msi_detector = MSIDetector()
        self.hrd_inferrer = HRDInferrer()
        self.io_checker = IOEligibilityChecker()
    
    async def calculate(
        self,
        patient_profile: PatientProfile,
        options: dict = None
    ) -> BiomarkerProfile:
        """
        Calculate all biomarkers for a patient.
        
        Args:
            patient_profile: Patient data with mutations
            options: Optional config (thresholds, etc.)
        
        Returns:
            BiomarkerProfile with all calculated values
        """
        logger.info(f"Calculating biomarkers for {patient_profile.patient_id}")
        
        # Convert mutations to dict format for calculators
        mutations = self._mutations_to_dicts(patient_profile.mutations)
        
        # Step 1: Calculate TMB
        tmb_result = self.tmb_calculator.calculate(
            mutations=mutations,
            exome_size_mb=options.get('exome_size_mb', 38.0) if options else 38.0,
            threshold=options.get('tmb_threshold', 10.0) if options else 10.0
        )
        
        # Step 2: Detect MSI
        msi_result = self.msi_detector.detect(
            mutations=mutations,
            germline=patient_profile.germline_panel
        )
        
        # Step 3: Infer HRD
        hrd_result = self.hrd_inferrer.infer(
            mutations=mutations,
            germline=patient_profile.germline_panel,
            myriad_score=options.get('myriad_hrd_score') if options else None
        )
        
        # Step 4: Determine IO eligibility
        io_eligible, io_reason = self.io_checker.check(
            tmb_result=tmb_result,
            msi_result=msi_result
        )
        
        # Step 5: Determine PARP eligibility
        parp_eligible, parp_reason = self._check_parp_eligibility(hrd_result)
        
        # Build profile
        profile = BiomarkerProfile(
            patient_id=patient_profile.patient_id,
            tmb=tmb_result,
            msi=msi_result,
            hrd=hrd_result,
            io_eligible=io_eligible,
            io_eligibility_reason=io_reason,
            parp_eligible=parp_eligible,
            parp_eligibility_reason=parp_reason,
            calculation_timestamp=datetime.utcnow(),
            provenance={
                'tmb_validation': 'TCGA Pan-Immune r=0.933, n=1895',
                'msi_method': 'dMMR gene mutation detection',
                'hrd_method': 'HRR/BER gene inference'
            }
        )
        
        logger.info(
            f"Biomarkers: TMB={tmb_result.value:.2f}, "
            f"MSI={msi_result.status.value}, "
            f"HRD={hrd_result.status.value}, "
            f"IO={io_eligible}"
        )
        
        return profile
    
    def _mutations_to_dicts(self, mutations: List) -> List[dict]:
        """Convert Mutation objects to dicts for calculators."""
        return [
            {
                'gene': m.gene,
                'variant': m.variant,
                'hgvs_p': m.hgvs_p,
                'hgvs_c': m.hgvs_c,
                'variant_classification': m.classification,
                'protein_change': m.hgvs_p
            }
            for m in mutations
        ]
    
    def _check_parp_eligibility(self, hrd_result: HRDResult) -> tuple:
        """Check PARP inhibitor eligibility."""
        if hrd_result.status in [HRDStatus.HRD_POSITIVE, HRDStatus.HRD_INFERRED]:
            reason = f"{hrd_result.status.value}"
            if hrd_result.mechanism:
                reason += f" ({hrd_result.mechanism})"
            return True, reason
        
        return False, "HRD not detected"
```

### TMB Calculator

```python
# api/services/biomarkers/tmb_calculator.py

from typing import List, Dict
from dataclasses import dataclass
from .constants import NONSYNONYMOUS_CLASSIFICATIONS, TCGA_EXOME_SIZE_MB

@dataclass
class TMBResult:
    value: float
    classification: str
    threshold_used: float
    mutation_count: int
    exome_size_mb: float
    validation: Dict[str, any]

class TMBCalculator:
    """
    Calculate Tumor Mutational Burden.
    
    Validated against TCGA Pan-Immune publication:
    - Pearson r = 0.933
    - Classification accuracy = 95.4%
    """
    
    def calculate(
        self,
        mutations: List[Dict],
        exome_size_mb: float = TCGA_EXOME_SIZE_MB,
        threshold: float = 10.0
    ) -> TMBResult:
        """
        Calculate TMB from mutation list.
        
        Args:
            mutations: List of mutation dicts with variant_classification
            exome_size_mb: Exome size in megabases (default: 38.0)
            threshold: TMB-H threshold (default: 10.0 mut/Mb)
        
        Returns:
            TMBResult with value and classification
        """
        # Count nonsynonymous mutations
        count = self._count_nonsynonymous(mutations)
        
        # Calculate TMB
        tmb_value = count / exome_size_mb if exome_size_mb > 0 else 0.0
        
        # Classify
        classification = "TMB-H" if tmb_value >= threshold else "TMB-L"
        
        return TMBResult(
            value=round(tmb_value, 2),
            classification=classification,
            threshold_used=threshold,
            mutation_count=count,
            exome_size_mb=exome_size_mb,
            validation={
                'method': 'nonsynonymous_count / exome_size',
                'ground_truth': 'TCGA Pan-Immune',
                'pearson_r': 0.933,
                'accuracy': 0.954,
                'n_validated': 1895
            }
        )
    
    def _count_nonsynonymous(self, mutations: List[Dict]) -> int:
        """Count nonsynonymous mutations."""
        count = 0
        for mut in mutations:
            classification = mut.get("variant_classification", "").strip()
            protein_change = mut.get("hgvs_p", "") or mut.get("protein_change", "")
            
            # Check standard MAF classifications
            if classification in NONSYNONYMOUS_CLASSIFICATIONS:
                count += 1
                continue
            
            # Handle simplified classifications (SNP, DEL, INS)
            if protein_change and protein_change.strip():
                if "=" in protein_change or protein_change.endswith("="):
                    continue  # Silent mutation
                if classification.upper() in ["SNP", "DEL", "INS", "ONP"]:
                    count += 1
        
        return count
```

### MSI Detector

```python
# api/services/biomarkers/msi_detector.py

from typing import List, Dict, Optional
from dataclasses import dataclass
from .constants import DMMR_GENES

@dataclass
class MSIResult:
    status: str
    dmmr_genes_mutated: List[str]
    dmmr_genes_checked: List[str]
    method: str
    confidence: float

class MSIDetector:
    """
    Detect Microsatellite Instability from dMMR gene mutations.
    
    dMMR genes: MLH1, MSH2, MSH6, PMS2, EPCAM
    """
    
    def detect(
        self,
        mutations: List[Dict],
        germline: Optional[dict] = None
    ) -> MSIResult:
        """
        Detect MSI status from dMMR gene mutations.
        
        Args:
            mutations: Somatic mutations
            germline: Optional germline panel results
        
        Returns:
            MSIResult with status and details
        """
        # Get mutated genes
        mutated_genes = {m.get('gene', '').upper() for m in mutations}
        
        # Check dMMR genes
        dmmr_mutated = []
        for gene in DMMR_GENES:
            if gene in mutated_genes:
                dmmr_mutated.append(gene)
        
        # Also check germline if available
        if germline and hasattr(germline, 'pathogenic'):
            for gene in DMMR_GENES:
                if gene in germline.pathogenic:
                    if gene not in dmmr_mutated:
                        dmmr_mutated.append(gene)
        
        # Determine status
        if len(dmmr_mutated) >= 1:
            status = "MSI-H"
            confidence = 0.85 if len(dmmr_mutated) >= 2 else 0.70
        else:
            status = "MSS"
            confidence = 0.80  # Lower confidence without assay
        
        return MSIResult(
            status=status,
            dmmr_genes_mutated=dmmr_mutated,
            dmmr_genes_checked=list(DMMR_GENES),
            method="mutation_based",
            confidence=confidence
        )
```

### HRD Inferrer

```python
# api/services/biomarkers/hrd_inferrer.py

from typing import List, Dict, Optional
from dataclasses import dataclass
from .constants import HRR_GENES, BER_GENES

@dataclass
class HRDResult:
    status: str
    score: Optional[float]
    mechanism: Optional[str]
    genes_mutated: List[str]
    genes_checked: List[str]
    confidence: float

class HRDInferrer:
    """
    Infer Homologous Recombination Deficiency from DNA repair gene mutations.
    
    HRR genes: BRCA1, BRCA2, ATM, ATR, CHEK1, CHEK2, RAD51C, RAD51D, PALB2, BARD1
    BER genes: MBD4, MUTYH, OGG1, NTHL1, NEIL1
    """
    
    def infer(
        self,
        mutations: List[Dict],
        germline: Optional[dict] = None,
        myriad_score: Optional[float] = None
    ) -> HRDResult:
        """
        Infer HRD status from DNA repair gene mutations.
        
        Args:
            mutations: Somatic mutations
            germline: Optional germline panel
            myriad_score: Optional Myriad HRD score (â‰¥42 = HRD+)
        
        Returns:
            HRDResult with status and mechanism
        """
        # If we have Myriad score, use it directly
        if myriad_score is not None:
            status = "HRD+" if myriad_score >= 42 else "HRD-"
            return HRDResult(
                status=status,
                score=myriad_score,
                mechanism="myriad_score",
                genes_mutated=[],
                genes_checked=list(HRR_GENES | BER_GENES),
                confidence=0.95
            )
        
        # Otherwise, infer from mutations
        mutated_genes = {m.get('gene', '').upper() for m in mutations}
        
        # Check HRR genes
        hrr_mutated = [g for g in HRR_GENES if g in mutated_genes]
        
        # Check BER genes
        ber_mutated = [g for g in BER_GENES if g in mutated_genes]
        
        # Check germline
        if germline and hasattr(germline, 'pathogenic'):
            for gene in HRR_GENES | BER_GENES:
                if gene in germline.pathogenic:
                    if gene in HRR_GENES and gene not in hrr_mutated:
                        hrr_mutated.append(gene)
                    if gene in BER_GENES and gene not in ber_mutated:
                        ber_mutated.append(gene)
        
        # Determine status and mechanism
        all_mutated = hrr_mutated + ber_mutated
        
        if 'BRCA1' in all_mutated or 'BRCA2' in all_mutated:
            status = "HRD-INFERRED"
            mechanism = "BRCA_MUTATION"
            confidence = 0.90
        elif hrr_mutated:
            status = "HRD-INFERRED"
            mechanism = f"HRR_MUTATION_{hrr_mutated[0]}"
            confidence = 0.75
        elif ber_mutated:
            status = "HRD-INFERRED"
            mechanism = f"BER_DEFICIENCY_{ber_mutated[0]}"
            confidence = 0.70
        else:
            status = "unknown"
            mechanism = None
            confidence = 0.50
        
        return HRDResult(
            status=status,
            score=None,
            mechanism=mechanism,
            genes_mutated=all_mutated,
            genes_checked=list(HRR_GENES | BER_GENES),
            confidence=confidence
        )
```

### Constants

```python
# api/services/biomarkers/constants.py

# TMB Constants
TCGA_EXOME_SIZE_MB = 38.0
TMB_HIGH_THRESHOLD_PRIMARY = 10.0
TMB_HIGH_THRESHOLD_SECONDARY = 20.0

# Nonsynonymous mutation classifications
NONSYNONYMOUS_CLASSIFICATIONS = {
    'Missense_Mutation',
    'Nonsense_Mutation',
    'Frame_Shift_Del',
    'Frame_Shift_Ins',
    'In_Frame_Del',
    'In_Frame_Ins',
    'Splice_Site',
    'Translation_Start_Site',
    'Nonstop_Mutation'
}

# dMMR genes for MSI detection
DMMR_GENES = {'MLH1', 'MSH2', 'MSH6', 'PMS2', 'EPCAM'}

# Homologous Recombination Repair genes
HRR_GENES = {
    'BRCA1', 'BRCA2', 'ATM', 'ATR', 
    'CHEK1', 'CHEK2', 'RAD51C', 'RAD51D', 
    'PALB2', 'BARD1', 'BRIP1', 'FANCA', 
    'FANCD2', 'NBN', 'RAD51B'
}

# Base Excision Repair genes
BER_GENES = {
    'MBD4', 'MUTYH', 'OGG1', 'NTHL1', 
    'NEIL1', 'NEIL2', 'NEIL3', 'APEX1', 
    'XRCC1', 'PARP1', 'PARP2'
}
```

---

## ðŸ§ª TESTING

### TMB Validation Test

```python
# api/services/biomarkers/tests/test_tmb.py

import pytest
from ..tmb_calculator import TMBCalculator

@pytest.fixture
def calculator():
    return TMBCalculator()

def test_tmb_calculation_basic(calculator):
    mutations = [
        {'variant_classification': 'Missense_Mutation'},
        {'variant_classification': 'Missense_Mutation'},
        {'variant_classification': 'Frame_Shift_Del'},
    ]
    
    result = calculator.calculate(mutations, exome_size_mb=38.0)
    
    assert result.mutation_count == 3
    assert result.value == pytest.approx(3/38.0, rel=0.01)
    assert result.classification == "TMB-L"

def test_tmb_high_classification(calculator):
    # 380 mutations / 38 Mb = 10 mut/Mb = TMB-H
    mutations = [{'variant_classification': 'Missense_Mutation'}] * 380
    
    result = calculator.calculate(mutations)
    
    assert result.classification == "TMB-H"
    assert result.value >= 10.0

def test_tmb_skips_silent(calculator):
    mutations = [
        {'variant_classification': 'Missense_Mutation'},
        {'variant_classification': 'Silent'},  # Should be skipped
    ]
    
    result = calculator.calculate(mutations)
    
    assert result.mutation_count == 1
```

---

## ðŸ“‹ IMPLEMENTATION CHECKLIST

### Phase 1: TMB Calculator
- [ ] Port validated TMB code from `scripts/data_acquisition/utils/tmb_calculator.py`
- [ ] Add TMBResult dataclass
- [ ] Add validation provenance
- [ ] Unit tests matching TCGA validation

### Phase 2: MSI Detector
- [ ] Implement dMMR gene checking
- [ ] Handle germline results
- [ ] Add confidence scoring
- [ ] Unit tests

### Phase 3: HRD Inferrer
- [ ] Implement HRR gene checking
- [ ] Implement BER gene checking (MBD4)
- [ ] Support Myriad score input
- [ ] Mechanism identification
- [ ] Unit tests

### Phase 4: Integration
- [ ] Create BiomarkerAgent class
- [ ] Wire all calculators
- [ ] Add IO eligibility logic
- [ ] Add PARP eligibility logic
- [ ] Integration tests

---

## ðŸ“¡ API ENDPOINT

```yaml
POST /api/agents/biomarkers
Content-Type: application/json

Request:
  patient_id: string
  mutations: Mutation[]
  options:
    exome_size_mb: number  # default: 38.0
    tmb_threshold: number  # default: 10.0
    myriad_hrd_score: number  # optional

Response:
  biomarker_profile: BiomarkerProfile
  calculation_time_ms: number
```

---

## âœ… ACCEPTANCE CRITERIA

1. âœ… TMB calculation matches validated r=0.933 against TCGA
2. âœ… TMB-H classification at â‰¥10 mut/Mb
3. âœ… MSI detection from dMMR gene mutations
4. âœ… HRD inference from HRR/BER gene mutations
5. âœ… IO eligibility = TMB-H OR MSI-H
6. âœ… PARP eligibility = HRD+ or BRCA mutant
7. âœ… All results include validation provenance
8. âœ… Unit test coverage >80%

---

---

## ðŸŽ¯ MISSION

Build a biomarker calculation agent that can:
1. Calculate TMB from mutation list (validated r=0.933)
2. Detect MSI status from dMMR gene mutations
3. Infer HRD status from DNA repair gene mutations
4. Determine IO eligibility (TMB-H OR MSI-H)
5. Provide validation provenance for all calculations

---

## ðŸ“Š VALIDATED CAPABILITIES (USE THESE)

### TMB Calculation - ALREADY VALIDATED âœ…

**Location:** `scripts/data_acquisition/utils/tmb_calculator.py`

**Validation Metrics:**
| Metric | Value | Ground Truth |
|--------|-------|--------------|
| Pearson r | 0.933 | TCGA Pan-Immune |
| Classification Accuracy | 95.4% | n=1,895 patients |
| Sensitivity | 96.0% | TMB-H detection |
| Specificity | 95.2% | TMB-L detection |

**Key Code:**
```python
# From scripts/data_acquisition/utils/tmb_calculator.py
TCGA_EXOME_SIZE_MB = 38.0
TMB_HIGH_THRESHOLD = 10.0  # mutations per megabase

NONSYNONYMOUS_CLASSIFICATIONS = {
    'Missense_Mutation', 'Nonsense_Mutation', 'Frame_Shift_Del',
    'Frame_Shift_Ins', 'In_Frame_Del', 'In_Frame_Ins',
    'Splice_Site', 'Translation_Start_Site', 'Nonstop_Mutation'
}

def count_nonsynonymous_mutations(mutations: List[Dict]) -> int:
    """Count nonsynonymous mutations."""
    count = 0
    for mut in mutations:
        classification = mut.get("variant_classification", "").strip()
        protein_change = mut.get("hgvs_p", "") or mut.get("protein_change", "")
        
        if classification in NONSYNONYMOUS_CLASSIFICATIONS:
            count += 1
        elif protein_change and classification.upper() in ["SNP", "DEL", "INS"]:
            count += 1
    
    return count

def calculate_tmb(mutations: List[Dict], exome_size_mb: float = TCGA_EXOME_SIZE_MB) -> float:
    """Calculate TMB as mutations per megabase."""
    nonsynonymous_count = count_nonsynonymous_mutations(mutations)
    return nonsynonymous_count / exome_size_mb
```

---

## ðŸ“¥ INPUTS

### From PatientProfile (Module 01)

```python
@dataclass
class PatientProfile:
    patient_id: str
    disease: str
    mutations: List[Mutation]
    # ... other fields
```

---

## ðŸ“¤ OUTPUTS

### BiomarkerProfile Schema

```python
from dataclasses import dataclass
from typing import Optional, Dict, List
from enum import Enum

class TMBClassification(Enum):
    TMB_HIGH = "TMB-H"
    TMB_LOW = "TMB-L"
    UNKNOWN = "unknown"

class MSIStatus(Enum):
    MSI_HIGH = "MSI-H"
    MSI_LOW = "MSI-L"
    MSS = "MSS"
    UNKNOWN = "unknown"

class HRDStatus(Enum):
    HRD_POSITIVE = "HRD+"
    HRD_NEGATIVE = "HRD-"
    HRD_INFERRED = "HRD-INFERRED"
    UNKNOWN = "unknown"

@dataclass
class TMBResult:
    value: float                        # Mutations per Mb
    classification: TMBClassification
    threshold_used: float               # e.g., 10.0
    mutation_count: int                 # Total nonsynonymous
    exome_size_mb: float               # e.g., 38.0
    validation: Dict[str, any]         # Provenance

@dataclass
class MSIResult:
    status: MSIStatus
    dmmr_genes_mutated: List[str]      # e.g., ["MLH1", "MSH2"]
    dmmr_genes_checked: List[str]      # All genes checked
    method: str                         # "mutation_based" or "assay"
    confidence: float                   # 0.0 - 1.0

@dataclass
class HRDResult:
    status: HRDStatus
    score: Optional[float]              # If Myriad score available
    mechanism: Optional[str]            # e.g., "BRCA1_LOSS", "MBD4_BER"
    genes_mutated: List[str]            # HRR/BER genes mutated
    genes_checked: List[str]            # All genes checked
    confidence: float

@dataclass
class BiomarkerProfile:
    patient_id: str
    tmb: TMBResult
    msi: MSIResult
    hrd: HRDResult
    io_eligible: bool                   # TMB-H OR MSI-H
    io_eligibility_reason: str          # "TMB-H (12.3 mut/Mb)"
    parp_eligible: bool                 # HRD+ or BRCA mutant
    parp_eligibility_reason: str
    calculation_timestamp: datetime
    provenance: Dict[str, any]          # Full audit trail
```

---

## ðŸ—ï¸ IMPLEMENTATION

### File Structure

```
api/services/biomarkers/
â”œâ”€â”€ __init__.py
â”œâ”€â”€ biomarker_agent.py          # Main agent
â”œâ”€â”€ tmb_calculator.py           # TMB logic (port from validated)
â”œâ”€â”€ msi_detector.py             # MSI detection
â”œâ”€â”€ hrd_inferrer.py             # HRD inference
â”œâ”€â”€ io_eligibility.py           # IO eligibility determination
â”œâ”€â”€ constants.py                # Gene lists, thresholds
â””â”€â”€ tests/
    â”œâ”€â”€ test_tmb.py
    â”œâ”€â”€ test_msi.py
    â”œâ”€â”€ test_hrd.py
    â””â”€â”€ test_io_eligibility.py
```

### Core Agent Implementation

```python
# api/services/biomarkers/biomarker_agent.py

from typing import List
from datetime import datetime
import logging

from .tmb_calculator import TMBCalculator
from .msi_detector import MSIDetector
from .hrd_inferrer import HRDInferrer
from .io_eligibility import IOEligibilityChecker
from ..models import PatientProfile, BiomarkerProfile

logger = logging.getLogger(__name__)

class BiomarkerAgent:
    """
    Calculate all biomarkers from patient mutation data.
    
    Capabilities:
    - TMB (validated r=0.933 vs TCGA)
    - MSI (dMMR gene-based detection)
    - HRD (HRR/BER gene inference)
    - IO eligibility (TMB-H OR MSI-H)
    """
    
    def __init__(self):
        self.tmb_calculator = TMBCalculator()
        self.msi_detector = MSIDetector()
        self.hrd_inferrer = HRDInferrer()
        self.io_checker = IOEligibilityChecker()
    
    async def calculate(
        self,
        patient_profile: PatientProfile,
        options: dict = None
    ) -> BiomarkerProfile:
        """
        Calculate all biomarkers for a patient.
        
        Args:
            patient_profile: Patient data with mutations
            options: Optional config (thresholds, etc.)
        
        Returns:
            BiomarkerProfile with all calculated values
        """
        logger.info(f"Calculating biomarkers for {patient_profile.patient_id}")
        
        # Convert mutations to dict format for calculators
        mutations = self._mutations_to_dicts(patient_profile.mutations)
        
        # Step 1: Calculate TMB
        tmb_result = self.tmb_calculator.calculate(
            mutations=mutations,
            exome_size_mb=options.get('exome_size_mb', 38.0) if options else 38.0,
            threshold=options.get('tmb_threshold', 10.0) if options else 10.0
        )
        
        # Step 2: Detect MSI
        msi_result = self.msi_detector.detect(
            mutations=mutations,
            germline=patient_profile.germline_panel
        )
        
        # Step 3: Infer HRD
        hrd_result = self.hrd_inferrer.infer(
            mutations=mutations,
            germline=patient_profile.germline_panel,
            myriad_score=options.get('myriad_hrd_score') if options else None
        )
        
        # Step 4: Determine IO eligibility
        io_eligible, io_reason = self.io_checker.check(
            tmb_result=tmb_result,
            msi_result=msi_result
        )
        
        # Step 5: Determine PARP eligibility
        parp_eligible, parp_reason = self._check_parp_eligibility(hrd_result)
        
        # Build profile
        profile = BiomarkerProfile(
            patient_id=patient_profile.patient_id,
            tmb=tmb_result,
            msi=msi_result,
            hrd=hrd_result,
            io_eligible=io_eligible,
            io_eligibility_reason=io_reason,
            parp_eligible=parp_eligible,
            parp_eligibility_reason=parp_reason,
            calculation_timestamp=datetime.utcnow(),
            provenance={
                'tmb_validation': 'TCGA Pan-Immune r=0.933, n=1895',
                'msi_method': 'dMMR gene mutation detection',
                'hrd_method': 'HRR/BER gene inference'
            }
        )
        
        logger.info(
            f"Biomarkers: TMB={tmb_result.value:.2f}, "
            f"MSI={msi_result.status.value}, "
            f"HRD={hrd_result.status.value}, "
            f"IO={io_eligible}"
        )
        
        return profile
    
    def _mutations_to_dicts(self, mutations: List) -> List[dict]:
        """Convert Mutation objects to dicts for calculators."""
        return [
            {
                'gene': m.gene,
                'variant': m.variant,
                'hgvs_p': m.hgvs_p,
                'hgvs_c': m.hgvs_c,
                'variant_classification': m.classification,
                'protein_change': m.hgvs_p
            }
            for m in mutations
        ]
    
    def _check_parp_eligibility(self, hrd_result: HRDResult) -> tuple:
        """Check PARP inhibitor eligibility."""
        if hrd_result.status in [HRDStatus.HRD_POSITIVE, HRDStatus.HRD_INFERRED]:
            reason = f"{hrd_result.status.value}"
            if hrd_result.mechanism:
                reason += f" ({hrd_result.mechanism})"
            return True, reason
        
        return False, "HRD not detected"
```

### TMB Calculator

```python
# api/services/biomarkers/tmb_calculator.py

from typing import List, Dict
from dataclasses import dataclass
from .constants import NONSYNONYMOUS_CLASSIFICATIONS, TCGA_EXOME_SIZE_MB

@dataclass
class TMBResult:
    value: float
    classification: str
    threshold_used: float
    mutation_count: int
    exome_size_mb: float
    validation: Dict[str, any]

class TMBCalculator:
    """
    Calculate Tumor Mutational Burden.
    
    Validated against TCGA Pan-Immune publication:
    - Pearson r = 0.933
    - Classification accuracy = 95.4%
    """
    
    def calculate(
        self,
        mutations: List[Dict],
        exome_size_mb: float = TCGA_EXOME_SIZE_MB,
        threshold: float = 10.0
    ) -> TMBResult:
        """
        Calculate TMB from mutation list.
        
        Args:
            mutations: List of mutation dicts with variant_classification
            exome_size_mb: Exome size in megabases (default: 38.0)
            threshold: TMB-H threshold (default: 10.0 mut/Mb)
        
        Returns:
            TMBResult with value and classification
        """
        # Count nonsynonymous mutations
        count = self._count_nonsynonymous(mutations)
        
        # Calculate TMB
        tmb_value = count / exome_size_mb if exome_size_mb > 0 else 0.0
        
        # Classify
        classification = "TMB-H" if tmb_value >= threshold else "TMB-L"
        
        return TMBResult(
            value=round(tmb_value, 2),
            classification=classification,
            threshold_used=threshold,
            mutation_count=count,
            exome_size_mb=exome_size_mb,
            validation={
                'method': 'nonsynonymous_count / exome_size',
                'ground_truth': 'TCGA Pan-Immune',
                'pearson_r': 0.933,
                'accuracy': 0.954,
                'n_validated': 1895
            }
        )
    
    def _count_nonsynonymous(self, mutations: List[Dict]) -> int:
        """Count nonsynonymous mutations."""
        count = 0
        for mut in mutations:
            classification = mut.get("variant_classification", "").strip()
            protein_change = mut.get("hgvs_p", "") or mut.get("protein_change", "")
            
            # Check standard MAF classifications
            if classification in NONSYNONYMOUS_CLASSIFICATIONS:
                count += 1
                continue
            
            # Handle simplified classifications (SNP, DEL, INS)
            if protein_change and protein_change.strip():
                if "=" in protein_change or protein_change.endswith("="):
                    continue  # Silent mutation
                if classification.upper() in ["SNP", "DEL", "INS", "ONP"]:
                    count += 1
        
        return count
```

### MSI Detector

```python
# api/services/biomarkers/msi_detector.py

from typing import List, Dict, Optional
from dataclasses import dataclass
from .constants import DMMR_GENES

@dataclass
class MSIResult:
    status: str
    dmmr_genes_mutated: List[str]
    dmmr_genes_checked: List[str]
    method: str
    confidence: float

class MSIDetector:
    """
    Detect Microsatellite Instability from dMMR gene mutations.
    
    dMMR genes: MLH1, MSH2, MSH6, PMS2, EPCAM
    """
    
    def detect(
        self,
        mutations: List[Dict],
        germline: Optional[dict] = None
    ) -> MSIResult:
        """
        Detect MSI status from dMMR gene mutations.
        
        Args:
            mutations: Somatic mutations
            germline: Optional germline panel results
        
        Returns:
            MSIResult with status and details
        """
        # Get mutated genes
        mutated_genes = {m.get('gene', '').upper() for m in mutations}
        
        # Check dMMR genes
        dmmr_mutated = []
        for gene in DMMR_GENES:
            if gene in mutated_genes:
                dmmr_mutated.append(gene)
        
        # Also check germline if available
        if germline and hasattr(germline, 'pathogenic'):
            for gene in DMMR_GENES:
                if gene in germline.pathogenic:
                    if gene not in dmmr_mutated:
                        dmmr_mutated.append(gene)
        
        # Determine status
        if len(dmmr_mutated) >= 1:
            status = "MSI-H"
            confidence = 0.85 if len(dmmr_mutated) >= 2 else 0.70
        else:
            status = "MSS"
            confidence = 0.80  # Lower confidence without assay
        
        return MSIResult(
            status=status,
            dmmr_genes_mutated=dmmr_mutated,
            dmmr_genes_checked=list(DMMR_GENES),
            method="mutation_based",
            confidence=confidence
        )
```

### HRD Inferrer

```python
# api/services/biomarkers/hrd_inferrer.py

from typing import List, Dict, Optional
from dataclasses import dataclass
from .constants import HRR_GENES, BER_GENES

@dataclass
class HRDResult:
    status: str
    score: Optional[float]
    mechanism: Optional[str]
    genes_mutated: List[str]
    genes_checked: List[str]
    confidence: float

class HRDInferrer:
    """
    Infer Homologous Recombination Deficiency from DNA repair gene mutations.
    
    HRR genes: BRCA1, BRCA2, ATM, ATR, CHEK1, CHEK2, RAD51C, RAD51D, PALB2, BARD1
    BER genes: MBD4, MUTYH, OGG1, NTHL1, NEIL1
    """
    
    def infer(
        self,
        mutations: List[Dict],
        germline: Optional[dict] = None,
        myriad_score: Optional[float] = None
    ) -> HRDResult:
        """
        Infer HRD status from DNA repair gene mutations.
        
        Args:
            mutations: Somatic mutations
            germline: Optional germline panel
            myriad_score: Optional Myriad HRD score (â‰¥42 = HRD+)
        
        Returns:
            HRDResult with status and mechanism
        """
        # If we have Myriad score, use it directly
        if myriad_score is not None:
            status = "HRD+" if myriad_score >= 42 else "HRD-"
            return HRDResult(
                status=status,
                score=myriad_score,
                mechanism="myriad_score",
                genes_mutated=[],
                genes_checked=list(HRR_GENES | BER_GENES),
                confidence=0.95
            )
        
        # Otherwise, infer from mutations
        mutated_genes = {m.get('gene', '').upper() for m in mutations}
        
        # Check HRR genes
        hrr_mutated = [g for g in HRR_GENES if g in mutated_genes]
        
        # Check BER genes
        ber_mutated = [g for g in BER_GENES if g in mutated_genes]
        
        # Check germline
        if germline and hasattr(germline, 'pathogenic'):
            for gene in HRR_GENES | BER_GENES:
                if gene in germline.pathogenic:
                    if gene in HRR_GENES and gene not in hrr_mutated:
                        hrr_mutated.append(gene)
                    if gene in BER_GENES and gene not in ber_mutated:
                        ber_mutated.append(gene)
        
        # Determine status and mechanism
        all_mutated = hrr_mutated + ber_mutated
        
        if 'BRCA1' in all_mutated or 'BRCA2' in all_mutated:
            status = "HRD-INFERRED"
            mechanism = "BRCA_MUTATION"
            confidence = 0.90
        elif hrr_mutated:
            status = "HRD-INFERRED"
            mechanism = f"HRR_MUTATION_{hrr_mutated[0]}"
            confidence = 0.75
        elif ber_mutated:
            status = "HRD-INFERRED"
            mechanism = f"BER_DEFICIENCY_{ber_mutated[0]}"
            confidence = 0.70
        else:
            status = "unknown"
            mechanism = None
            confidence = 0.50
        
        return HRDResult(
            status=status,
            score=None,
            mechanism=mechanism,
            genes_mutated=all_mutated,
            genes_checked=list(HRR_GENES | BER_GENES),
            confidence=confidence
        )
```

### Constants

```python
# api/services/biomarkers/constants.py

# TMB Constants
TCGA_EXOME_SIZE_MB = 38.0
TMB_HIGH_THRESHOLD_PRIMARY = 10.0
TMB_HIGH_THRESHOLD_SECONDARY = 20.0

# Nonsynonymous mutation classifications
NONSYNONYMOUS_CLASSIFICATIONS = {
    'Missense_Mutation',
    'Nonsense_Mutation',
    'Frame_Shift_Del',
    'Frame_Shift_Ins',
    'In_Frame_Del',
    'In_Frame_Ins',
    'Splice_Site',
    'Translation_Start_Site',
    'Nonstop_Mutation'
}

# dMMR genes for MSI detection
DMMR_GENES = {'MLH1', 'MSH2', 'MSH6', 'PMS2', 'EPCAM'}

# Homologous Recombination Repair genes
HRR_GENES = {
    'BRCA1', 'BRCA2', 'ATM', 'ATR', 
    'CHEK1', 'CHEK2', 'RAD51C', 'RAD51D', 
    'PALB2', 'BARD1', 'BRIP1', 'FANCA', 
    'FANCD2', 'NBN', 'RAD51B'
}

# Base Excision Repair genes
BER_GENES = {
    'MBD4', 'MUTYH', 'OGG1', 'NTHL1', 
    'NEIL1', 'NEIL2', 'NEIL3', 'APEX1', 
    'XRCC1', 'PARP1', 'PARP2'
}
```

---

## ðŸ§ª TESTING

### TMB Validation Test

```python
# api/services/biomarkers/tests/test_tmb.py

import pytest
from ..tmb_calculator import TMBCalculator

@pytest.fixture
def calculator():
    return TMBCalculator()

def test_tmb_calculation_basic(calculator):
    mutations = [
        {'variant_classification': 'Missense_Mutation'},
        {'variant_classification': 'Missense_Mutation'},
        {'variant_classification': 'Frame_Shift_Del'},
    ]
    
    result = calculator.calculate(mutations, exome_size_mb=38.0)
    
    assert result.mutation_count == 3
    assert result.value == pytest.approx(3/38.0, rel=0.01)
    assert result.classification == "TMB-L"

def test_tmb_high_classification(calculator):
    # 380 mutations / 38 Mb = 10 mut/Mb = TMB-H
    mutations = [{'variant_classification': 'Missense_Mutation'}] * 380
    
    result = calculator.calculate(mutations)
    
    assert result.classification == "TMB-H"
    assert result.value >= 10.0

def test_tmb_skips_silent(calculator):
    mutations = [
        {'variant_classification': 'Missense_Mutation'},
        {'variant_classification': 'Silent'},  # Should be skipped
    ]
    
    result = calculator.calculate(mutations)
    
    assert result.mutation_count == 1
```

---

## ðŸ“‹ IMPLEMENTATION CHECKLIST

### Phase 1: TMB Calculator
- [ ] Port validated TMB code from `scripts/data_acquisition/utils/tmb_calculator.py`
- [ ] Add TMBResult dataclass
- [ ] Add validation provenance
- [ ] Unit tests matching TCGA validation

### Phase 2: MSI Detector
- [ ] Implement dMMR gene checking
- [ ] Handle germline results
- [ ] Add confidence scoring
- [ ] Unit tests

### Phase 3: HRD Inferrer
- [ ] Implement HRR gene checking
- [ ] Implement BER gene checking (MBD4)
- [ ] Support Myriad score input
- [ ] Mechanism identification
- [ ] Unit tests

### Phase 4: Integration
- [ ] Create BiomarkerAgent class
- [ ] Wire all calculators
- [ ] Add IO eligibility logic
- [ ] Add PARP eligibility logic
- [ ] Integration tests

---

## ðŸ“¡ API ENDPOINT

```yaml
POST /api/agents/biomarkers
Content-Type: application/json

Request:
  patient_id: string
  mutations: Mutation[]
  options:
    exome_size_mb: number  # default: 38.0
    tmb_threshold: number  # default: 10.0
    myriad_hrd_score: number  # optional

Response:
  biomarker_profile: BiomarkerProfile
  calculation_time_ms: number
```

---

## âœ… ACCEPTANCE CRITERIA

1. âœ… TMB calculation matches validated r=0.933 against TCGA
2. âœ… TMB-H classification at â‰¥10 mut/Mb
3. âœ… MSI detection from dMMR gene mutations
4. âœ… HRD inference from HRR/BER gene mutations
5. âœ… IO eligibility = TMB-H OR MSI-H
6. âœ… PARP eligibility = HRD+ or BRCA mutant
7. âœ… All results include validation provenance
8. âœ… Unit test coverage >80%

---

---

## ðŸŽ¯ MISSION

Build a biomarker calculation agent that can:
1. Calculate TMB from mutation list (validated r=0.933)
2. Detect MSI status from dMMR gene mutations
3. Infer HRD status from DNA repair gene mutations
4. Determine IO eligibility (TMB-H OR MSI-H)
5. Provide validation provenance for all calculations

---

## ðŸ“Š VALIDATED CAPABILITIES (USE THESE)

### TMB Calculation - ALREADY VALIDATED âœ…

**Location:** `scripts/data_acquisition/utils/tmb_calculator.py`

**Validation Metrics:**
| Metric | Value | Ground Truth |
|--------|-------|--------------|
| Pearson r | 0.933 | TCGA Pan-Immune |
| Classification Accuracy | 95.4% | n=1,895 patients |
| Sensitivity | 96.0% | TMB-H detection |
| Specificity | 95.2% | TMB-L detection |

**Key Code:**
```python
# From scripts/data_acquisition/utils/tmb_calculator.py
TCGA_EXOME_SIZE_MB = 38.0
TMB_HIGH_THRESHOLD = 10.0  # mutations per megabase

NONSYNONYMOUS_CLASSIFICATIONS = {
    'Missense_Mutation', 'Nonsense_Mutation', 'Frame_Shift_Del',
    'Frame_Shift_Ins', 'In_Frame_Del', 'In_Frame_Ins',
    'Splice_Site', 'Translation_Start_Site', 'Nonstop_Mutation'
}

def count_nonsynonymous_mutations(mutations: List[Dict]) -> int:
    """Count nonsynonymous mutations."""
    count = 0
    for mut in mutations:
        classification = mut.get("variant_classification", "").strip()
        protein_change = mut.get("hgvs_p", "") or mut.get("protein_change", "")
        
        if classification in NONSYNONYMOUS_CLASSIFICATIONS:
            count += 1
        elif protein_change and classification.upper() in ["SNP", "DEL", "INS"]:
            count += 1
    
    return count

def calculate_tmb(mutations: List[Dict], exome_size_mb: float = TCGA_EXOME_SIZE_MB) -> float:
    """Calculate TMB as mutations per megabase."""
    nonsynonymous_count = count_nonsynonymous_mutations(mutations)
    return nonsynonymous_count / exome_size_mb
```

---

## ðŸ“¥ INPUTS

### From PatientProfile (Module 01)

```python
@dataclass
class PatientProfile:
    patient_id: str
    disease: str
    mutations: List[Mutation]
    # ... other fields
```

---

## ðŸ“¤ OUTPUTS

### BiomarkerProfile Schema

```python
from dataclasses import dataclass
from typing import Optional, Dict, List
from enum import Enum

class TMBClassification(Enum):
    TMB_HIGH = "TMB-H"
    TMB_LOW = "TMB-L"
    UNKNOWN = "unknown"

class MSIStatus(Enum):
    MSI_HIGH = "MSI-H"
    MSI_LOW = "MSI-L"
    MSS = "MSS"
    UNKNOWN = "unknown"

class HRDStatus(Enum):
    HRD_POSITIVE = "HRD+"
    HRD_NEGATIVE = "HRD-"
    HRD_INFERRED = "HRD-INFERRED"
    UNKNOWN = "unknown"

@dataclass
class TMBResult:
    value: float                        # Mutations per Mb
    classification: TMBClassification
    threshold_used: float               # e.g., 10.0
    mutation_count: int                 # Total nonsynonymous
    exome_size_mb: float               # e.g., 38.0
    validation: Dict[str, any]         # Provenance

@dataclass
class MSIResult:
    status: MSIStatus
    dmmr_genes_mutated: List[str]      # e.g., ["MLH1", "MSH2"]
    dmmr_genes_checked: List[str]      # All genes checked
    method: str                         # "mutation_based" or "assay"
    confidence: float                   # 0.0 - 1.0

@dataclass
class HRDResult:
    status: HRDStatus
    score: Optional[float]              # If Myriad score available
    mechanism: Optional[str]            # e.g., "BRCA1_LOSS", "MBD4_BER"
    genes_mutated: List[str]            # HRR/BER genes mutated
    genes_checked: List[str]            # All genes checked
    confidence: float

@dataclass
class BiomarkerProfile:
    patient_id: str
    tmb: TMBResult
    msi: MSIResult
    hrd: HRDResult
    io_eligible: bool                   # TMB-H OR MSI-H
    io_eligibility_reason: str          # "TMB-H (12.3 mut/Mb)"
    parp_eligible: bool                 # HRD+ or BRCA mutant
    parp_eligibility_reason: str
    calculation_timestamp: datetime
    provenance: Dict[str, any]          # Full audit trail
```

---

## ðŸ—ï¸ IMPLEMENTATION

### File Structure

```
api/services/biomarkers/
â”œâ”€â”€ __init__.py
â”œâ”€â”€ biomarker_agent.py          # Main agent
â”œâ”€â”€ tmb_calculator.py           # TMB logic (port from validated)
â”œâ”€â”€ msi_detector.py             # MSI detection
â”œâ”€â”€ hrd_inferrer.py             # HRD inference
â”œâ”€â”€ io_eligibility.py           # IO eligibility determination
â”œâ”€â”€ constants.py                # Gene lists, thresholds
â””â”€â”€ tests/
    â”œâ”€â”€ test_tmb.py
    â”œâ”€â”€ test_msi.py
    â”œâ”€â”€ test_hrd.py
    â””â”€â”€ test_io_eligibility.py
```

### Core Agent Implementation

```python
# api/services/biomarkers/biomarker_agent.py

from typing import List
from datetime import datetime
import logging

from .tmb_calculator import TMBCalculator
from .msi_detector import MSIDetector
from .hrd_inferrer import HRDInferrer
from .io_eligibility import IOEligibilityChecker
from ..models import PatientProfile, BiomarkerProfile

logger = logging.getLogger(__name__)

class BiomarkerAgent:
    """
    Calculate all biomarkers from patient mutation data.
    
    Capabilities:
    - TMB (validated r=0.933 vs TCGA)
    - MSI (dMMR gene-based detection)
    - HRD (HRR/BER gene inference)
    - IO eligibility (TMB-H OR MSI-H)
    """
    
    def __init__(self):
        self.tmb_calculator = TMBCalculator()
        self.msi_detector = MSIDetector()
        self.hrd_inferrer = HRDInferrer()
        self.io_checker = IOEligibilityChecker()
    
    async def calculate(
        self,
        patient_profile: PatientProfile,
        options: dict = None
    ) -> BiomarkerProfile:
        """
        Calculate all biomarkers for a patient.
        
        Args:
            patient_profile: Patient data with mutations
            options: Optional config (thresholds, etc.)
        
        Returns:
            BiomarkerProfile with all calculated values
        """
        logger.info(f"Calculating biomarkers for {patient_profile.patient_id}")
        
        # Convert mutations to dict format for calculators
        mutations = self._mutations_to_dicts(patient_profile.mutations)
        
        # Step 1: Calculate TMB
        tmb_result = self.tmb_calculator.calculate(
            mutations=mutations,
            exome_size_mb=options.get('exome_size_mb', 38.0) if options else 38.0,
            threshold=options.get('tmb_threshold', 10.0) if options else 10.0
        )
        
        # Step 2: Detect MSI
        msi_result = self.msi_detector.detect(
            mutations=mutations,
            germline=patient_profile.germline_panel
        )
        
        # Step 3: Infer HRD
        hrd_result = self.hrd_inferrer.infer(
            mutations=mutations,
            germline=patient_profile.germline_panel,
            myriad_score=options.get('myriad_hrd_score') if options else None
        )
        
        # Step 4: Determine IO eligibility
        io_eligible, io_reason = self.io_checker.check(
            tmb_result=tmb_result,
            msi_result=msi_result
        )
        
        # Step 5: Determine PARP eligibility
        parp_eligible, parp_reason = self._check_parp_eligibility(hrd_result)
        
        # Build profile
        profile = BiomarkerProfile(
            patient_id=patient_profile.patient_id,
            tmb=tmb_result,
            msi=msi_result,
            hrd=hrd_result,
            io_eligible=io_eligible,
            io_eligibility_reason=io_reason,
            parp_eligible=parp_eligible,
            parp_eligibility_reason=parp_reason,
            calculation_timestamp=datetime.utcnow(),
            provenance={
                'tmb_validation': 'TCGA Pan-Immune r=0.933, n=1895',
                'msi_method': 'dMMR gene mutation detection',
                'hrd_method': 'HRR/BER gene inference'
            }
        )
        
        logger.info(
            f"Biomarkers: TMB={tmb_result.value:.2f}, "
            f"MSI={msi_result.status.value}, "
            f"HRD={hrd_result.status.value}, "
            f"IO={io_eligible}"
        )
        
        return profile
    
    def _mutations_to_dicts(self, mutations: List) -> List[dict]:
        """Convert Mutation objects to dicts for calculators."""
        return [
            {
                'gene': m.gene,
                'variant': m.variant,
                'hgvs_p': m.hgvs_p,
                'hgvs_c': m.hgvs_c,
                'variant_classification': m.classification,
                'protein_change': m.hgvs_p
            }
            for m in mutations
        ]
    
    def _check_parp_eligibility(self, hrd_result: HRDResult) -> tuple:
        """Check PARP inhibitor eligibility."""
        if hrd_result.status in [HRDStatus.HRD_POSITIVE, HRDStatus.HRD_INFERRED]:
            reason = f"{hrd_result.status.value}"
            if hrd_result.mechanism:
                reason += f" ({hrd_result.mechanism})"
            return True, reason
        
        return False, "HRD not detected"
```

### TMB Calculator

```python
# api/services/biomarkers/tmb_calculator.py

from typing import List, Dict
from dataclasses import dataclass
from .constants import NONSYNONYMOUS_CLASSIFICATIONS, TCGA_EXOME_SIZE_MB

@dataclass
class TMBResult:
    value: float
    classification: str
    threshold_used: float
    mutation_count: int
    exome_size_mb: float
    validation: Dict[str, any]

class TMBCalculator:
    """
    Calculate Tumor Mutational Burden.
    
    Validated against TCGA Pan-Immune publication:
    - Pearson r = 0.933
    - Classification accuracy = 95.4%
    """
    
    def calculate(
        self,
        mutations: List[Dict],
        exome_size_mb: float = TCGA_EXOME_SIZE_MB,
        threshold: float = 10.0
    ) -> TMBResult:
        """
        Calculate TMB from mutation list.
        
        Args:
            mutations: List of mutation dicts with variant_classification
            exome_size_mb: Exome size in megabases (default: 38.0)
            threshold: TMB-H threshold (default: 10.0 mut/Mb)
        
        Returns:
            TMBResult with value and classification
        """
        # Count nonsynonymous mutations
        count = self._count_nonsynonymous(mutations)
        
        # Calculate TMB
        tmb_value = count / exome_size_mb if exome_size_mb > 0 else 0.0
        
        # Classify
        classification = "TMB-H" if tmb_value >= threshold else "TMB-L"
        
        return TMBResult(
            value=round(tmb_value, 2),
            classification=classification,
            threshold_used=threshold,
            mutation_count=count,
            exome_size_mb=exome_size_mb,
            validation={
                'method': 'nonsynonymous_count / exome_size',
                'ground_truth': 'TCGA Pan-Immune',
                'pearson_r': 0.933,
                'accuracy': 0.954,
                'n_validated': 1895
            }
        )
    
    def _count_nonsynonymous(self, mutations: List[Dict]) -> int:
        """Count nonsynonymous mutations."""
        count = 0
        for mut in mutations:
            classification = mut.get("variant_classification", "").strip()
            protein_change = mut.get("hgvs_p", "") or mut.get("protein_change", "")
            
            # Check standard MAF classifications
            if classification in NONSYNONYMOUS_CLASSIFICATIONS:
                count += 1
                continue
            
            # Handle simplified classifications (SNP, DEL, INS)
            if protein_change and protein_change.strip():
                if "=" in protein_change or protein_change.endswith("="):
                    continue  # Silent mutation
                if classification.upper() in ["SNP", "DEL", "INS", "ONP"]:
                    count += 1
        
        return count
```

### MSI Detector

```python
# api/services/biomarkers/msi_detector.py

from typing import List, Dict, Optional
from dataclasses import dataclass
from .constants import DMMR_GENES

@dataclass
class MSIResult:
    status: str
    dmmr_genes_mutated: List[str]
    dmmr_genes_checked: List[str]
    method: str
    confidence: float

class MSIDetector:
    """
    Detect Microsatellite Instability from dMMR gene mutations.
    
    dMMR genes: MLH1, MSH2, MSH6, PMS2, EPCAM
    """
    
    def detect(
        self,
        mutations: List[Dict],
        germline: Optional[dict] = None
    ) -> MSIResult:
        """
        Detect MSI status from dMMR gene mutations.
        
        Args:
            mutations: Somatic mutations
            germline: Optional germline panel results
        
        Returns:
            MSIResult with status and details
        """
        # Get mutated genes
        mutated_genes = {m.get('gene', '').upper() for m in mutations}
        
        # Check dMMR genes
        dmmr_mutated = []
        for gene in DMMR_GENES:
            if gene in mutated_genes:
                dmmr_mutated.append(gene)
        
        # Also check germline if available
        if germline and hasattr(germline, 'pathogenic'):
            for gene in DMMR_GENES:
                if gene in germline.pathogenic:
                    if gene not in dmmr_mutated:
                        dmmr_mutated.append(gene)
        
        # Determine status
        if len(dmmr_mutated) >= 1:
            status = "MSI-H"
            confidence = 0.85 if len(dmmr_mutated) >= 2 else 0.70
        else:
            status = "MSS"
            confidence = 0.80  # Lower confidence without assay
        
        return MSIResult(
            status=status,
            dmmr_genes_mutated=dmmr_mutated,
            dmmr_genes_checked=list(DMMR_GENES),
            method="mutation_based",
            confidence=confidence
        )
```

### HRD Inferrer

```python
# api/services/biomarkers/hrd_inferrer.py

from typing import List, Dict, Optional
from dataclasses import dataclass
from .constants import HRR_GENES, BER_GENES

@dataclass
class HRDResult:
    status: str
    score: Optional[float]
    mechanism: Optional[str]
    genes_mutated: List[str]
    genes_checked: List[str]
    confidence: float

class HRDInferrer:
    """
    Infer Homologous Recombination Deficiency from DNA repair gene mutations.
    
    HRR genes: BRCA1, BRCA2, ATM, ATR, CHEK1, CHEK2, RAD51C, RAD51D, PALB2, BARD1
    BER genes: MBD4, MUTYH, OGG1, NTHL1, NEIL1
    """
    
    def infer(
        self,
        mutations: List[Dict],
        germline: Optional[dict] = None,
        myriad_score: Optional[float] = None
    ) -> HRDResult:
        """
        Infer HRD status from DNA repair gene mutations.
        
        Args:
            mutations: Somatic mutations
            germline: Optional germline panel
            myriad_score: Optional Myriad HRD score (â‰¥42 = HRD+)
        
        Returns:
            HRDResult with status and mechanism
        """
        # If we have Myriad score, use it directly
        if myriad_score is not None:
            status = "HRD+" if myriad_score >= 42 else "HRD-"
            return HRDResult(
                status=status,
                score=myriad_score,
                mechanism="myriad_score",
                genes_mutated=[],
                genes_checked=list(HRR_GENES | BER_GENES),
                confidence=0.95
            )
        
        # Otherwise, infer from mutations
        mutated_genes = {m.get('gene', '').upper() for m in mutations}
        
        # Check HRR genes
        hrr_mutated = [g for g in HRR_GENES if g in mutated_genes]
        
        # Check BER genes
        ber_mutated = [g for g in BER_GENES if g in mutated_genes]
        
        # Check germline
        if germline and hasattr(germline, 'pathogenic'):
            for gene in HRR_GENES | BER_GENES:
                if gene in germline.pathogenic:
                    if gene in HRR_GENES and gene not in hrr_mutated:
                        hrr_mutated.append(gene)
                    if gene in BER_GENES and gene not in ber_mutated:
                        ber_mutated.append(gene)
        
        # Determine status and mechanism
        all_mutated = hrr_mutated + ber_mutated
        
        if 'BRCA1' in all_mutated or 'BRCA2' in all_mutated:
            status = "HRD-INFERRED"
            mechanism = "BRCA_MUTATION"
            confidence = 0.90
        elif hrr_mutated:
            status = "HRD-INFERRED"
            mechanism = f"HRR_MUTATION_{hrr_mutated[0]}"
            confidence = 0.75
        elif ber_mutated:
            status = "HRD-INFERRED"
            mechanism = f"BER_DEFICIENCY_{ber_mutated[0]}"
            confidence = 0.70
        else:
            status = "unknown"
            mechanism = None
            confidence = 0.50
        
        return HRDResult(
            status=status,
            score=None,
            mechanism=mechanism,
            genes_mutated=all_mutated,
            genes_checked=list(HRR_GENES | BER_GENES),
            confidence=confidence
        )
```

### Constants

```python
# api/services/biomarkers/constants.py

# TMB Constants
TCGA_EXOME_SIZE_MB = 38.0
TMB_HIGH_THRESHOLD_PRIMARY = 10.0
TMB_HIGH_THRESHOLD_SECONDARY = 20.0

# Nonsynonymous mutation classifications
NONSYNONYMOUS_CLASSIFICATIONS = {
    'Missense_Mutation',
    'Nonsense_Mutation',
    'Frame_Shift_Del',
    'Frame_Shift_Ins',
    'In_Frame_Del',
    'In_Frame_Ins',
    'Splice_Site',
    'Translation_Start_Site',
    'Nonstop_Mutation'
}

# dMMR genes for MSI detection
DMMR_GENES = {'MLH1', 'MSH2', 'MSH6', 'PMS2', 'EPCAM'}

# Homologous Recombination Repair genes
HRR_GENES = {
    'BRCA1', 'BRCA2', 'ATM', 'ATR', 
    'CHEK1', 'CHEK2', 'RAD51C', 'RAD51D', 
    'PALB2', 'BARD1', 'BRIP1', 'FANCA', 
    'FANCD2', 'NBN', 'RAD51B'
}

# Base Excision Repair genes
BER_GENES = {
    'MBD4', 'MUTYH', 'OGG1', 'NTHL1', 
    'NEIL1', 'NEIL2', 'NEIL3', 'APEX1', 
    'XRCC1', 'PARP1', 'PARP2'
}
```

---

## ðŸ§ª TESTING

### TMB Validation Test

```python
# api/services/biomarkers/tests/test_tmb.py

import pytest
from ..tmb_calculator import TMBCalculator

@pytest.fixture
def calculator():
    return TMBCalculator()

def test_tmb_calculation_basic(calculator):
    mutations = [
        {'variant_classification': 'Missense_Mutation'},
        {'variant_classification': 'Missense_Mutation'},
        {'variant_classification': 'Frame_Shift_Del'},
    ]
    
    result = calculator.calculate(mutations, exome_size_mb=38.0)
    
    assert result.mutation_count == 3
    assert result.value == pytest.approx(3/38.0, rel=0.01)
    assert result.classification == "TMB-L"

def test_tmb_high_classification(calculator):
    # 380 mutations / 38 Mb = 10 mut/Mb = TMB-H
    mutations = [{'variant_classification': 'Missense_Mutation'}] * 380
    
    result = calculator.calculate(mutations)
    
    assert result.classification == "TMB-H"
    assert result.value >= 10.0

def test_tmb_skips_silent(calculator):
    mutations = [
        {'variant_classification': 'Missense_Mutation'},
        {'variant_classification': 'Silent'},  # Should be skipped
    ]
    
    result = calculator.calculate(mutations)
    
    assert result.mutation_count == 1
```

---

## ðŸ“‹ IMPLEMENTATION CHECKLIST

### Phase 1: TMB Calculator
- [ ] Port validated TMB code from `scripts/data_acquisition/utils/tmb_calculator.py`
- [ ] Add TMBResult dataclass
- [ ] Add validation provenance
- [ ] Unit tests matching TCGA validation

### Phase 2: MSI Detector
- [ ] Implement dMMR gene checking
- [ ] Handle germline results
- [ ] Add confidence scoring
- [ ] Unit tests

### Phase 3: HRD Inferrer
- [ ] Implement HRR gene checking
- [ ] Implement BER gene checking (MBD4)
- [ ] Support Myriad score input
- [ ] Mechanism identification
- [ ] Unit tests

### Phase 4: Integration
- [ ] Create BiomarkerAgent class
- [ ] Wire all calculators
- [ ] Add IO eligibility logic
- [ ] Add PARP eligibility logic
- [ ] Integration tests

---

## ðŸ“¡ API ENDPOINT

```yaml
POST /api/agents/biomarkers
Content-Type: application/json

Request:
  patient_id: string
  mutations: Mutation[]
  options:
    exome_size_mb: number  # default: 38.0
    tmb_threshold: number  # default: 10.0
    myriad_hrd_score: number  # optional

Response:
  biomarker_profile: BiomarkerProfile
  calculation_time_ms: number
```

---

## âœ… ACCEPTANCE CRITERIA

1. âœ… TMB calculation matches validated r=0.933 against TCGA
2. âœ… TMB-H classification at â‰¥10 mut/Mb
3. âœ… MSI detection from dMMR gene mutations
4. âœ… HRD inference from HRR/BER gene mutations
5. âœ… IO eligibility = TMB-H OR MSI-H
6. âœ… PARP eligibility = HRD+ or BRCA mutant
7. âœ… All results include validation provenance
8. âœ… Unit test coverage >80%

---

---

## ðŸŽ¯ MISSION

Build a biomarker calculation agent that can:
1. Calculate TMB from mutation list (validated r=0.933)
2. Detect MSI status from dMMR gene mutations
3. Infer HRD status from DNA repair gene mutations
4. Determine IO eligibility (TMB-H OR MSI-H)
5. Provide validation provenance for all calculations

---

## ðŸ“Š VALIDATED CAPABILITIES (USE THESE)

### TMB Calculation - ALREADY VALIDATED âœ…

**Location:** `scripts/data_acquisition/utils/tmb_calculator.py`

**Validation Metrics:**
| Metric | Value | Ground Truth |
|--------|-------|--------------|
| Pearson r | 0.933 | TCGA Pan-Immune |
| Classification Accuracy | 95.4% | n=1,895 patients |
| Sensitivity | 96.0% | TMB-H detection |
| Specificity | 95.2% | TMB-L detection |

**Key Code:**
```python
# From scripts/data_acquisition/utils/tmb_calculator.py
TCGA_EXOME_SIZE_MB = 38.0
TMB_HIGH_THRESHOLD = 10.0  # mutations per megabase

NONSYNONYMOUS_CLASSIFICATIONS = {
    'Missense_Mutation', 'Nonsense_Mutation', 'Frame_Shift_Del',
    'Frame_Shift_Ins', 'In_Frame_Del', 'In_Frame_Ins',
    'Splice_Site', 'Translation_Start_Site', 'Nonstop_Mutation'
}

def count_nonsynonymous_mutations(mutations: List[Dict]) -> int:
    """Count nonsynonymous mutations."""
    count = 0
    for mut in mutations:
        classification = mut.get("variant_classification", "").strip()
        protein_change = mut.get("hgvs_p", "") or mut.get("protein_change", "")
        
        if classification in NONSYNONYMOUS_CLASSIFICATIONS:
            count += 1
        elif protein_change and classification.upper() in ["SNP", "DEL", "INS"]:
            count += 1
    
    return count

def calculate_tmb(mutations: List[Dict], exome_size_mb: float = TCGA_EXOME_SIZE_MB) -> float:
    """Calculate TMB as mutations per megabase."""
    nonsynonymous_count = count_nonsynonymous_mutations(mutations)
    return nonsynonymous_count / exome_size_mb
```

---

## ðŸ“¥ INPUTS

### From PatientProfile (Module 01)

```python
@dataclass
class PatientProfile:
    patient_id: str
    disease: str
    mutations: List[Mutation]
    # ... other fields
```

---

## ðŸ“¤ OUTPUTS

### BiomarkerProfile Schema

```python
from dataclasses import dataclass
from typing import Optional, Dict, List
from enum import Enum

class TMBClassification(Enum):
    TMB_HIGH = "TMB-H"
    TMB_LOW = "TMB-L"
    UNKNOWN = "unknown"

class MSIStatus(Enum):
    MSI_HIGH = "MSI-H"
    MSI_LOW = "MSI-L"
    MSS = "MSS"
    UNKNOWN = "unknown"

class HRDStatus(Enum):
    HRD_POSITIVE = "HRD+"
    HRD_NEGATIVE = "HRD-"
    HRD_INFERRED = "HRD-INFERRED"
    UNKNOWN = "unknown"

@dataclass
class TMBResult:
    value: float                        # Mutations per Mb
    classification: TMBClassification
    threshold_used: float               # e.g., 10.0
    mutation_count: int                 # Total nonsynonymous
    exome_size_mb: float               # e.g., 38.0
    validation: Dict[str, any]         # Provenance

@dataclass
class MSIResult:
    status: MSIStatus
    dmmr_genes_mutated: List[str]      # e.g., ["MLH1", "MSH2"]
    dmmr_genes_checked: List[str]      # All genes checked
    method: str                         # "mutation_based" or "assay"
    confidence: float                   # 0.0 - 1.0

@dataclass
class HRDResult:
    status: HRDStatus
    score: Optional[float]              # If Myriad score available
    mechanism: Optional[str]            # e.g., "BRCA1_LOSS", "MBD4_BER"
    genes_mutated: List[str]            # HRR/BER genes mutated
    genes_checked: List[str]            # All genes checked
    confidence: float

@dataclass
class BiomarkerProfile:
    patient_id: str
    tmb: TMBResult
    msi: MSIResult
    hrd: HRDResult
    io_eligible: bool                   # TMB-H OR MSI-H
    io_eligibility_reason: str          # "TMB-H (12.3 mut/Mb)"
    parp_eligible: bool                 # HRD+ or BRCA mutant
    parp_eligibility_reason: str
    calculation_timestamp: datetime
    provenance: Dict[str, any]          # Full audit trail
```

---

## ðŸ—ï¸ IMPLEMENTATION

### File Structure

```
api/services/biomarkers/
â”œâ”€â”€ __init__.py
â”œâ”€â”€ biomarker_agent.py          # Main agent
â”œâ”€â”€ tmb_calculator.py           # TMB logic (port from validated)
â”œâ”€â”€ msi_detector.py             # MSI detection
â”œâ”€â”€ hrd_inferrer.py             # HRD inference
â”œâ”€â”€ io_eligibility.py           # IO eligibility determination
â”œâ”€â”€ constants.py                # Gene lists, thresholds
â””â”€â”€ tests/
    â”œâ”€â”€ test_tmb.py
    â”œâ”€â”€ test_msi.py
    â”œâ”€â”€ test_hrd.py
    â””â”€â”€ test_io_eligibility.py
```

### Core Agent Implementation

```python
# api/services/biomarkers/biomarker_agent.py

from typing import List
from datetime import datetime
import logging

from .tmb_calculator import TMBCalculator
from .msi_detector import MSIDetector
from .hrd_inferrer import HRDInferrer
from .io_eligibility import IOEligibilityChecker
from ..models import PatientProfile, BiomarkerProfile

logger = logging.getLogger(__name__)

class BiomarkerAgent:
    """
    Calculate all biomarkers from patient mutation data.
    
    Capabilities:
    - TMB (validated r=0.933 vs TCGA)
    - MSI (dMMR gene-based detection)
    - HRD (HRR/BER gene inference)
    - IO eligibility (TMB-H OR MSI-H)
    """
    
    def __init__(self):
        self.tmb_calculator = TMBCalculator()
        self.msi_detector = MSIDetector()
        self.hrd_inferrer = HRDInferrer()
        self.io_checker = IOEligibilityChecker()
    
    async def calculate(
        self,
        patient_profile: PatientProfile,
        options: dict = None
    ) -> BiomarkerProfile:
        """
        Calculate all biomarkers for a patient.
        
        Args:
            patient_profile: Patient data with mutations
            options: Optional config (thresholds, etc.)
        
        Returns:
            BiomarkerProfile with all calculated values
        """
        logger.info(f"Calculating biomarkers for {patient_profile.patient_id}")
        
        # Convert mutations to dict format for calculators
        mutations = self._mutations_to_dicts(patient_profile.mutations)
        
        # Step 1: Calculate TMB
        tmb_result = self.tmb_calculator.calculate(
            mutations=mutations,
            exome_size_mb=options.get('exome_size_mb', 38.0) if options else 38.0,
            threshold=options.get('tmb_threshold', 10.0) if options else 10.0
        )
        
        # Step 2: Detect MSI
        msi_result = self.msi_detector.detect(
            mutations=mutations,
            germline=patient_profile.germline_panel
        )
        
        # Step 3: Infer HRD
        hrd_result = self.hrd_inferrer.infer(
            mutations=mutations,
            germline=patient_profile.germline_panel,
            myriad_score=options.get('myriad_hrd_score') if options else None
        )
        
        # Step 4: Determine IO eligibility
        io_eligible, io_reason = self.io_checker.check(
            tmb_result=tmb_result,
            msi_result=msi_result
        )
        
        # Step 5: Determine PARP eligibility
        parp_eligible, parp_reason = self._check_parp_eligibility(hrd_result)
        
        # Build profile
        profile = BiomarkerProfile(
            patient_id=patient_profile.patient_id,
            tmb=tmb_result,
            msi=msi_result,
            hrd=hrd_result,
            io_eligible=io_eligible,
            io_eligibility_reason=io_reason,
            parp_eligible=parp_eligible,
            parp_eligibility_reason=parp_reason,
            calculation_timestamp=datetime.utcnow(),
            provenance={
                'tmb_validation': 'TCGA Pan-Immune r=0.933, n=1895',
                'msi_method': 'dMMR gene mutation detection',
                'hrd_method': 'HRR/BER gene inference'
            }
        )
        
        logger.info(
            f"Biomarkers: TMB={tmb_result.value:.2f}, "
            f"MSI={msi_result.status.value}, "
            f"HRD={hrd_result.status.value}, "
            f"IO={io_eligible}"
        )
        
        return profile
    
    def _mutations_to_dicts(self, mutations: List) -> List[dict]:
        """Convert Mutation objects to dicts for calculators."""
        return [
            {
                'gene': m.gene,
                'variant': m.variant,
                'hgvs_p': m.hgvs_p,
                'hgvs_c': m.hgvs_c,
                'variant_classification': m.classification,
                'protein_change': m.hgvs_p
            }
            for m in mutations
        ]
    
    def _check_parp_eligibility(self, hrd_result: HRDResult) -> tuple:
        """Check PARP inhibitor eligibility."""
        if hrd_result.status in [HRDStatus.HRD_POSITIVE, HRDStatus.HRD_INFERRED]:
            reason = f"{hrd_result.status.value}"
            if hrd_result.mechanism:
                reason += f" ({hrd_result.mechanism})"
            return True, reason
        
        return False, "HRD not detected"
```

### TMB Calculator

```python
# api/services/biomarkers/tmb_calculator.py

from typing import List, Dict
from dataclasses import dataclass
from .constants import NONSYNONYMOUS_CLASSIFICATIONS, TCGA_EXOME_SIZE_MB

@dataclass
class TMBResult:
    value: float
    classification: str
    threshold_used: float
    mutation_count: int
    exome_size_mb: float
    validation: Dict[str, any]

class TMBCalculator:
    """
    Calculate Tumor Mutational Burden.
    
    Validated against TCGA Pan-Immune publication:
    - Pearson r = 0.933
    - Classification accuracy = 95.4%
    """
    
    def calculate(
        self,
        mutations: List[Dict],
        exome_size_mb: float = TCGA_EXOME_SIZE_MB,
        threshold: float = 10.0
    ) -> TMBResult:
        """
        Calculate TMB from mutation list.
        
        Args:
            mutations: List of mutation dicts with variant_classification
            exome_size_mb: Exome size in megabases (default: 38.0)
            threshold: TMB-H threshold (default: 10.0 mut/Mb)
        
        Returns:
            TMBResult with value and classification
        """
        # Count nonsynonymous mutations
        count = self._count_nonsynonymous(mutations)
        
        # Calculate TMB
        tmb_value = count / exome_size_mb if exome_size_mb > 0 else 0.0
        
        # Classify
        classification = "TMB-H" if tmb_value >= threshold else "TMB-L"
        
        return TMBResult(
            value=round(tmb_value, 2),
            classification=classification,
            threshold_used=threshold,
            mutation_count=count,
            exome_size_mb=exome_size_mb,
            validation={
                'method': 'nonsynonymous_count / exome_size',
                'ground_truth': 'TCGA Pan-Immune',
                'pearson_r': 0.933,
                'accuracy': 0.954,
                'n_validated': 1895
            }
        )
    
    def _count_nonsynonymous(self, mutations: List[Dict]) -> int:
        """Count nonsynonymous mutations."""
        count = 0
        for mut in mutations:
            classification = mut.get("variant_classification", "").strip()
            protein_change = mut.get("hgvs_p", "") or mut.get("protein_change", "")
            
            # Check standard MAF classifications
            if classification in NONSYNONYMOUS_CLASSIFICATIONS:
                count += 1
                continue
            
            # Handle simplified classifications (SNP, DEL, INS)
            if protein_change and protein_change.strip():
                if "=" in protein_change or protein_change.endswith("="):
                    continue  # Silent mutation
                if classification.upper() in ["SNP", "DEL", "INS", "ONP"]:
                    count += 1
        
        return count
```

### MSI Detector

```python
# api/services/biomarkers/msi_detector.py

from typing import List, Dict, Optional
from dataclasses import dataclass
from .constants import DMMR_GENES

@dataclass
class MSIResult:
    status: str
    dmmr_genes_mutated: List[str]
    dmmr_genes_checked: List[str]
    method: str
    confidence: float

class MSIDetector:
    """
    Detect Microsatellite Instability from dMMR gene mutations.
    
    dMMR genes: MLH1, MSH2, MSH6, PMS2, EPCAM
    """
    
    def detect(
        self,
        mutations: List[Dict],
        germline: Optional[dict] = None
    ) -> MSIResult:
        """
        Detect MSI status from dMMR gene mutations.
        
        Args:
            mutations: Somatic mutations
            germline: Optional germline panel results
        
        Returns:
            MSIResult with status and details
        """
        # Get mutated genes
        mutated_genes = {m.get('gene', '').upper() for m in mutations}
        
        # Check dMMR genes
        dmmr_mutated = []
        for gene in DMMR_GENES:
            if gene in mutated_genes:
                dmmr_mutated.append(gene)
        
        # Also check germline if available
        if germline and hasattr(germline, 'pathogenic'):
            for gene in DMMR_GENES:
                if gene in germline.pathogenic:
                    if gene not in dmmr_mutated:
                        dmmr_mutated.append(gene)
        
        # Determine status
        if len(dmmr_mutated) >= 1:
            status = "MSI-H"
            confidence = 0.85 if len(dmmr_mutated) >= 2 else 0.70
        else:
            status = "MSS"
            confidence = 0.80  # Lower confidence without assay
        
        return MSIResult(
            status=status,
            dmmr_genes_mutated=dmmr_mutated,
            dmmr_genes_checked=list(DMMR_GENES),
            method="mutation_based",
            confidence=confidence
        )
```

### HRD Inferrer

```python
# api/services/biomarkers/hrd_inferrer.py

from typing import List, Dict, Optional
from dataclasses import dataclass
from .constants import HRR_GENES, BER_GENES

@dataclass
class HRDResult:
    status: str
    score: Optional[float]
    mechanism: Optional[str]
    genes_mutated: List[str]
    genes_checked: List[str]
    confidence: float

class HRDInferrer:
    """
    Infer Homologous Recombination Deficiency from DNA repair gene mutations.
    
    HRR genes: BRCA1, BRCA2, ATM, ATR, CHEK1, CHEK2, RAD51C, RAD51D, PALB2, BARD1
    BER genes: MBD4, MUTYH, OGG1, NTHL1, NEIL1
    """
    
    def infer(
        self,
        mutations: List[Dict],
        germline: Optional[dict] = None,
        myriad_score: Optional[float] = None
    ) -> HRDResult:
        """
        Infer HRD status from DNA repair gene mutations.
        
        Args:
            mutations: Somatic mutations
            germline: Optional germline panel
            myriad_score: Optional Myriad HRD score (â‰¥42 = HRD+)
        
        Returns:
            HRDResult with status and mechanism
        """
        # If we have Myriad score, use it directly
        if myriad_score is not None:
            status = "HRD+" if myriad_score >= 42 else "HRD-"
            return HRDResult(
                status=status,
                score=myriad_score,
                mechanism="myriad_score",
                genes_mutated=[],
                genes_checked=list(HRR_GENES | BER_GENES),
                confidence=0.95
            )
        
        # Otherwise, infer from mutations
        mutated_genes = {m.get('gene', '').upper() for m in mutations}
        
        # Check HRR genes
        hrr_mutated = [g for g in HRR_GENES if g in mutated_genes]
        
        # Check BER genes
        ber_mutated = [g for g in BER_GENES if g in mutated_genes]
        
        # Check germline
        if germline and hasattr(germline, 'pathogenic'):
            for gene in HRR_GENES | BER_GENES:
                if gene in germline.pathogenic:
                    if gene in HRR_GENES and gene not in hrr_mutated:
                        hrr_mutated.append(gene)
                    if gene in BER_GENES and gene not in ber_mutated:
                        ber_mutated.append(gene)
        
        # Determine status and mechanism
        all_mutated = hrr_mutated + ber_mutated
        
        if 'BRCA1' in all_mutated or 'BRCA2' in all_mutated:
            status = "HRD-INFERRED"
            mechanism = "BRCA_MUTATION"
            confidence = 0.90
        elif hrr_mutated:
            status = "HRD-INFERRED"
            mechanism = f"HRR_MUTATION_{hrr_mutated[0]}"
            confidence = 0.75
        elif ber_mutated:
            status = "HRD-INFERRED"
            mechanism = f"BER_DEFICIENCY_{ber_mutated[0]}"
            confidence = 0.70
        else:
            status = "unknown"
            mechanism = None
            confidence = 0.50
        
        return HRDResult(
            status=status,
            score=None,
            mechanism=mechanism,
            genes_mutated=all_mutated,
            genes_checked=list(HRR_GENES | BER_GENES),
            confidence=confidence
        )
```

### Constants

```python
# api/services/biomarkers/constants.py

# TMB Constants
TCGA_EXOME_SIZE_MB = 38.0
TMB_HIGH_THRESHOLD_PRIMARY = 10.0
TMB_HIGH_THRESHOLD_SECONDARY = 20.0

# Nonsynonymous mutation classifications
NONSYNONYMOUS_CLASSIFICATIONS = {
    'Missense_Mutation',
    'Nonsense_Mutation',
    'Frame_Shift_Del',
    'Frame_Shift_Ins',
    'In_Frame_Del',
    'In_Frame_Ins',
    'Splice_Site',
    'Translation_Start_Site',
    'Nonstop_Mutation'
}

# dMMR genes for MSI detection
DMMR_GENES = {'MLH1', 'MSH2', 'MSH6', 'PMS2', 'EPCAM'}

# Homologous Recombination Repair genes
HRR_GENES = {
    'BRCA1', 'BRCA2', 'ATM', 'ATR', 
    'CHEK1', 'CHEK2', 'RAD51C', 'RAD51D', 
    'PALB2', 'BARD1', 'BRIP1', 'FANCA', 
    'FANCD2', 'NBN', 'RAD51B'
}

# Base Excision Repair genes
BER_GENES = {
    'MBD4', 'MUTYH', 'OGG1', 'NTHL1', 
    'NEIL1', 'NEIL2', 'NEIL3', 'APEX1', 
    'XRCC1', 'PARP1', 'PARP2'
}
```

---

## ðŸ§ª TESTING

### TMB Validation Test

```python
# api/services/biomarkers/tests/test_tmb.py

import pytest
from ..tmb_calculator import TMBCalculator

@pytest.fixture
def calculator():
    return TMBCalculator()

def test_tmb_calculation_basic(calculator):
    mutations = [
        {'variant_classification': 'Missense_Mutation'},
        {'variant_classification': 'Missense_Mutation'},
        {'variant_classification': 'Frame_Shift_Del'},
    ]
    
    result = calculator.calculate(mutations, exome_size_mb=38.0)
    
    assert result.mutation_count == 3
    assert result.value == pytest.approx(3/38.0, rel=0.01)
    assert result.classification == "TMB-L"

def test_tmb_high_classification(calculator):
    # 380 mutations / 38 Mb = 10 mut/Mb = TMB-H
    mutations = [{'variant_classification': 'Missense_Mutation'}] * 380
    
    result = calculator.calculate(mutations)
    
    assert result.classification == "TMB-H"
    assert result.value >= 10.0

def test_tmb_skips_silent(calculator):
    mutations = [
        {'variant_classification': 'Missense_Mutation'},
        {'variant_classification': 'Silent'},  # Should be skipped
    ]
    
    result = calculator.calculate(mutations)
    
    assert result.mutation_count == 1
```

---

## ðŸ“‹ IMPLEMENTATION CHECKLIST

### Phase 1: TMB Calculator
- [ ] Port validated TMB code from `scripts/data_acquisition/utils/tmb_calculator.py`
- [ ] Add TMBResult dataclass
- [ ] Add validation provenance
- [ ] Unit tests matching TCGA validation

### Phase 2: MSI Detector
- [ ] Implement dMMR gene checking
- [ ] Handle germline results
- [ ] Add confidence scoring
- [ ] Unit tests

### Phase 3: HRD Inferrer
- [ ] Implement HRR gene checking
- [ ] Implement BER gene checking (MBD4)
- [ ] Support Myriad score input
- [ ] Mechanism identification
- [ ] Unit tests

### Phase 4: Integration
- [ ] Create BiomarkerAgent class
- [ ] Wire all calculators
- [ ] Add IO eligibility logic
- [ ] Add PARP eligibility logic
- [ ] Integration tests

---

## ðŸ“¡ API ENDPOINT

```yaml
POST /api/agents/biomarkers
Content-Type: application/json

Request:
  patient_id: string
  mutations: Mutation[]
  options:
    exome_size_mb: number  # default: 38.0
    tmb_threshold: number  # default: 10.0
    myriad_hrd_score: number  # optional

Response:
  biomarker_profile: BiomarkerProfile
  calculation_time_ms: number
```

---

## âœ… ACCEPTANCE CRITERIA

1. âœ… TMB calculation matches validated r=0.933 against TCGA
2. âœ… TMB-H classification at â‰¥10 mut/Mb
3. âœ… MSI detection from dMMR gene mutations
4. âœ… HRD inference from HRR/BER gene mutations
5. âœ… IO eligibility = TMB-H OR MSI-H
6. âœ… PARP eligibility = HRD+ or BRCA mutant
7. âœ… All results include validation provenance
8. âœ… Unit test coverage >80%

---

---

## ðŸŽ¯ MISSION

Build a biomarker calculation agent that can:
1. Calculate TMB from mutation list (validated r=0.933)
2. Detect MSI status from dMMR gene mutations
3. Infer HRD status from DNA repair gene mutations
4. Determine IO eligibility (TMB-H OR MSI-H)
5. Provide validation provenance for all calculations

---

## ðŸ“Š VALIDATED CAPABILITIES (USE THESE)

### TMB Calculation - ALREADY VALIDATED âœ…

**Location:** `scripts/data_acquisition/utils/tmb_calculator.py`

**Validation Metrics:**
| Metric | Value | Ground Truth |
|--------|-------|--------------|
| Pearson r | 0.933 | TCGA Pan-Immune |
| Classification Accuracy | 95.4% | n=1,895 patients |
| Sensitivity | 96.0% | TMB-H detection |
| Specificity | 95.2% | TMB-L detection |

**Key Code:**
```python
# From scripts/data_acquisition/utils/tmb_calculator.py
TCGA_EXOME_SIZE_MB = 38.0
TMB_HIGH_THRESHOLD = 10.0  # mutations per megabase

NONSYNONYMOUS_CLASSIFICATIONS = {
    'Missense_Mutation', 'Nonsense_Mutation', 'Frame_Shift_Del',
    'Frame_Shift_Ins', 'In_Frame_Del', 'In_Frame_Ins',
    'Splice_Site', 'Translation_Start_Site', 'Nonstop_Mutation'
}

def count_nonsynonymous_mutations(mutations: List[Dict]) -> int:
    """Count nonsynonymous mutations."""
    count = 0
    for mut in mutations:
        classification = mut.get("variant_classification", "").strip()
        protein_change = mut.get("hgvs_p", "") or mut.get("protein_change", "")
        
        if classification in NONSYNONYMOUS_CLASSIFICATIONS:
            count += 1
        elif protein_change and classification.upper() in ["SNP", "DEL", "INS"]:
            count += 1
    
    return count

def calculate_tmb(mutations: List[Dict], exome_size_mb: float = TCGA_EXOME_SIZE_MB) -> float:
    """Calculate TMB as mutations per megabase."""
    nonsynonymous_count = count_nonsynonymous_mutations(mutations)
    return nonsynonymous_count / exome_size_mb
```

---

## ðŸ“¥ INPUTS

### From PatientProfile (Module 01)

```python
@dataclass
class PatientProfile:
    patient_id: str
    disease: str
    mutations: List[Mutation]
    # ... other fields
```

---

## ðŸ“¤ OUTPUTS

### BiomarkerProfile Schema

```python
from dataclasses import dataclass
from typing import Optional, Dict, List
from enum import Enum

class TMBClassification(Enum):
    TMB_HIGH = "TMB-H"
    TMB_LOW = "TMB-L"
    UNKNOWN = "unknown"

class MSIStatus(Enum):
    MSI_HIGH = "MSI-H"
    MSI_LOW = "MSI-L"
    MSS = "MSS"
    UNKNOWN = "unknown"

class HRDStatus(Enum):
    HRD_POSITIVE = "HRD+"
    HRD_NEGATIVE = "HRD-"
    HRD_INFERRED = "HRD-INFERRED"
    UNKNOWN = "unknown"

@dataclass
class TMBResult:
    value: float                        # Mutations per Mb
    classification: TMBClassification
    threshold_used: float               # e.g., 10.0
    mutation_count: int                 # Total nonsynonymous
    exome_size_mb: float               # e.g., 38.0
    validation: Dict[str, any]         # Provenance

@dataclass
class MSIResult:
    status: MSIStatus
    dmmr_genes_mutated: List[str]      # e.g., ["MLH1", "MSH2"]
    dmmr_genes_checked: List[str]      # All genes checked
    method: str                         # "mutation_based" or "assay"
    confidence: float                   # 0.0 - 1.0

@dataclass
class HRDResult:
    status: HRDStatus
    score: Optional[float]              # If Myriad score available
    mechanism: Optional[str]            # e.g., "BRCA1_LOSS", "MBD4_BER"
    genes_mutated: List[str]            # HRR/BER genes mutated
    genes_checked: List[str]            # All genes checked
    confidence: float

@dataclass
class BiomarkerProfile:
    patient_id: str
    tmb: TMBResult
    msi: MSIResult
    hrd: HRDResult
    io_eligible: bool                   # TMB-H OR MSI-H
    io_eligibility_reason: str          # "TMB-H (12.3 mut/Mb)"
    parp_eligible: bool                 # HRD+ or BRCA mutant
    parp_eligibility_reason: str
    calculation_timestamp: datetime
    provenance: Dict[str, any]          # Full audit trail
```

---

## ðŸ—ï¸ IMPLEMENTATION

### File Structure

```
api/services/biomarkers/
â”œâ”€â”€ __init__.py
â”œâ”€â”€ biomarker_agent.py          # Main agent
â”œâ”€â”€ tmb_calculator.py           # TMB logic (port from validated)
â”œâ”€â”€ msi_detector.py             # MSI detection
â”œâ”€â”€ hrd_inferrer.py             # HRD inference
â”œâ”€â”€ io_eligibility.py           # IO eligibility determination
â”œâ”€â”€ constants.py                # Gene lists, thresholds
â””â”€â”€ tests/
    â”œâ”€â”€ test_tmb.py
    â”œâ”€â”€ test_msi.py
    â”œâ”€â”€ test_hrd.py
    â””â”€â”€ test_io_eligibility.py
```

### Core Agent Implementation

```python
# api/services/biomarkers/biomarker_agent.py

from typing import List
from datetime import datetime
import logging

from .tmb_calculator import TMBCalculator
from .msi_detector import MSIDetector
from .hrd_inferrer import HRDInferrer
from .io_eligibility import IOEligibilityChecker
from ..models import PatientProfile, BiomarkerProfile

logger = logging.getLogger(__name__)

class BiomarkerAgent:
    """
    Calculate all biomarkers from patient mutation data.
    
    Capabilities:
    - TMB (validated r=0.933 vs TCGA)
    - MSI (dMMR gene-based detection)
    - HRD (HRR/BER gene inference)
    - IO eligibility (TMB-H OR MSI-H)
    """
    
    def __init__(self):
        self.tmb_calculator = TMBCalculator()
        self.msi_detector = MSIDetector()
        self.hrd_inferrer = HRDInferrer()
        self.io_checker = IOEligibilityChecker()
    
    async def calculate(
        self,
        patient_profile: PatientProfile,
        options: dict = None
    ) -> BiomarkerProfile:
        """
        Calculate all biomarkers for a patient.
        
        Args:
            patient_profile: Patient data with mutations
            options: Optional config (thresholds, etc.)
        
        Returns:
            BiomarkerProfile with all calculated values
        """
        logger.info(f"Calculating biomarkers for {patient_profile.patient_id}")
        
        # Convert mutations to dict format for calculators
        mutations = self._mutations_to_dicts(patient_profile.mutations)
        
        # Step 1: Calculate TMB
        tmb_result = self.tmb_calculator.calculate(
            mutations=mutations,
            exome_size_mb=options.get('exome_size_mb', 38.0) if options else 38.0,
            threshold=options.get('tmb_threshold', 10.0) if options else 10.0
        )
        
        # Step 2: Detect MSI
        msi_result = self.msi_detector.detect(
            mutations=mutations,
            germline=patient_profile.germline_panel
        )
        
        # Step 3: Infer HRD
        hrd_result = self.hrd_inferrer.infer(
            mutations=mutations,
            germline=patient_profile.germline_panel,
            myriad_score=options.get('myriad_hrd_score') if options else None
        )
        
        # Step 4: Determine IO eligibility
        io_eligible, io_reason = self.io_checker.check(
            tmb_result=tmb_result,
            msi_result=msi_result
        )
        
        # Step 5: Determine PARP eligibility
        parp_eligible, parp_reason = self._check_parp_eligibility(hrd_result)
        
        # Build profile
        profile = BiomarkerProfile(
            patient_id=patient_profile.patient_id,
            tmb=tmb_result,
            msi=msi_result,
            hrd=hrd_result,
            io_eligible=io_eligible,
            io_eligibility_reason=io_reason,
            parp_eligible=parp_eligible,
            parp_eligibility_reason=parp_reason,
            calculation_timestamp=datetime.utcnow(),
            provenance={
                'tmb_validation': 'TCGA Pan-Immune r=0.933, n=1895',
                'msi_method': 'dMMR gene mutation detection',
                'hrd_method': 'HRR/BER gene inference'
            }
        )
        
        logger.info(
            f"Biomarkers: TMB={tmb_result.value:.2f}, "
            f"MSI={msi_result.status.value}, "
            f"HRD={hrd_result.status.value}, "
            f"IO={io_eligible}"
        )
        
        return profile
    
    def _mutations_to_dicts(self, mutations: List) -> List[dict]:
        """Convert Mutation objects to dicts for calculators."""
        return [
            {
                'gene': m.gene,
                'variant': m.variant,
                'hgvs_p': m.hgvs_p,
                'hgvs_c': m.hgvs_c,
                'variant_classification': m.classification,
                'protein_change': m.hgvs_p
            }
            for m in mutations
        ]
    
    def _check_parp_eligibility(self, hrd_result: HRDResult) -> tuple:
        """Check PARP inhibitor eligibility."""
        if hrd_result.status in [HRDStatus.HRD_POSITIVE, HRDStatus.HRD_INFERRED]:
            reason = f"{hrd_result.status.value}"
            if hrd_result.mechanism:
                reason += f" ({hrd_result.mechanism})"
            return True, reason
        
        return False, "HRD not detected"
```

### TMB Calculator

```python
# api/services/biomarkers/tmb_calculator.py

from typing import List, Dict
from dataclasses import dataclass
from .constants import NONSYNONYMOUS_CLASSIFICATIONS, TCGA_EXOME_SIZE_MB

@dataclass
class TMBResult:
    value: float
    classification: str
    threshold_used: float
    mutation_count: int
    exome_size_mb: float
    validation: Dict[str, any]

class TMBCalculator:
    """
    Calculate Tumor Mutational Burden.
    
    Validated against TCGA Pan-Immune publication:
    - Pearson r = 0.933
    - Classification accuracy = 95.4%
    """
    
    def calculate(
        self,
        mutations: List[Dict],
        exome_size_mb: float = TCGA_EXOME_SIZE_MB,
        threshold: float = 10.0
    ) -> TMBResult:
        """
        Calculate TMB from mutation list.
        
        Args:
            mutations: List of mutation dicts with variant_classification
            exome_size_mb: Exome size in megabases (default: 38.0)
            threshold: TMB-H threshold (default: 10.0 mut/Mb)
        
        Returns:
            TMBResult with value and classification
        """
        # Count nonsynonymous mutations
        count = self._count_nonsynonymous(mutations)
        
        # Calculate TMB
        tmb_value = count / exome_size_mb if exome_size_mb > 0 else 0.0
        
        # Classify
        classification = "TMB-H" if tmb_value >= threshold else "TMB-L"
        
        return TMBResult(
            value=round(tmb_value, 2),
            classification=classification,
            threshold_used=threshold,
            mutation_count=count,
            exome_size_mb=exome_size_mb,
            validation={
                'method': 'nonsynonymous_count / exome_size',
                'ground_truth': 'TCGA Pan-Immune',
                'pearson_r': 0.933,
                'accuracy': 0.954,
                'n_validated': 1895
            }
        )
    
    def _count_nonsynonymous(self, mutations: List[Dict]) -> int:
        """Count nonsynonymous mutations."""
        count = 0
        for mut in mutations:
            classification = mut.get("variant_classification", "").strip()
            protein_change = mut.get("hgvs_p", "") or mut.get("protein_change", "")
            
            # Check standard MAF classifications
            if classification in NONSYNONYMOUS_CLASSIFICATIONS:
                count += 1
                continue
            
            # Handle simplified classifications (SNP, DEL, INS)
            if protein_change and protein_change.strip():
                if "=" in protein_change or protein_change.endswith("="):
                    continue  # Silent mutation
                if classification.upper() in ["SNP", "DEL", "INS", "ONP"]:
                    count += 1
        
        return count
```

### MSI Detector

```python
# api/services/biomarkers/msi_detector.py

from typing import List, Dict, Optional
from dataclasses import dataclass
from .constants import DMMR_GENES

@dataclass
class MSIResult:
    status: str
    dmmr_genes_mutated: List[str]
    dmmr_genes_checked: List[str]
    method: str
    confidence: float

class MSIDetector:
    """
    Detect Microsatellite Instability from dMMR gene mutations.
    
    dMMR genes: MLH1, MSH2, MSH6, PMS2, EPCAM
    """
    
    def detect(
        self,
        mutations: List[Dict],
        germline: Optional[dict] = None
    ) -> MSIResult:
        """
        Detect MSI status from dMMR gene mutations.
        
        Args:
            mutations: Somatic mutations
            germline: Optional germline panel results
        
        Returns:
            MSIResult with status and details
        """
        # Get mutated genes
        mutated_genes = {m.get('gene', '').upper() for m in mutations}
        
        # Check dMMR genes
        dmmr_mutated = []
        for gene in DMMR_GENES:
            if gene in mutated_genes:
                dmmr_mutated.append(gene)
        
        # Also check germline if available
        if germline and hasattr(germline, 'pathogenic'):
            for gene in DMMR_GENES:
                if gene in germline.pathogenic:
                    if gene not in dmmr_mutated:
                        dmmr_mutated.append(gene)
        
        # Determine status
        if len(dmmr_mutated) >= 1:
            status = "MSI-H"
            confidence = 0.85 if len(dmmr_mutated) >= 2 else 0.70
        else:
            status = "MSS"
            confidence = 0.80  # Lower confidence without assay
        
        return MSIResult(
            status=status,
            dmmr_genes_mutated=dmmr_mutated,
            dmmr_genes_checked=list(DMMR_GENES),
            method="mutation_based",
            confidence=confidence
        )
```

### HRD Inferrer

```python
# api/services/biomarkers/hrd_inferrer.py

from typing import List, Dict, Optional
from dataclasses import dataclass
from .constants import HRR_GENES, BER_GENES

@dataclass
class HRDResult:
    status: str
    score: Optional[float]
    mechanism: Optional[str]
    genes_mutated: List[str]
    genes_checked: List[str]
    confidence: float

class HRDInferrer:
    """
    Infer Homologous Recombination Deficiency from DNA repair gene mutations.
    
    HRR genes: BRCA1, BRCA2, ATM, ATR, CHEK1, CHEK2, RAD51C, RAD51D, PALB2, BARD1
    BER genes: MBD4, MUTYH, OGG1, NTHL1, NEIL1
    """
    
    def infer(
        self,
        mutations: List[Dict],
        germline: Optional[dict] = None,
        myriad_score: Optional[float] = None
    ) -> HRDResult:
        """
        Infer HRD status from DNA repair gene mutations.
        
        Args:
            mutations: Somatic mutations
            germline: Optional germline panel
            myriad_score: Optional Myriad HRD score (â‰¥42 = HRD+)
        
        Returns:
            HRDResult with status and mechanism
        """
        # If we have Myriad score, use it directly
        if myriad_score is not None:
            status = "HRD+" if myriad_score >= 42 else "HRD-"
            return HRDResult(
                status=status,
                score=myriad_score,
                mechanism="myriad_score",
                genes_mutated=[],
                genes_checked=list(HRR_GENES | BER_GENES),
                confidence=0.95
            )
        
        # Otherwise, infer from mutations
        mutated_genes = {m.get('gene', '').upper() for m in mutations}
        
        # Check HRR genes
        hrr_mutated = [g for g in HRR_GENES if g in mutated_genes]
        
        # Check BER genes
        ber_mutated = [g for g in BER_GENES if g in mutated_genes]
        
        # Check germline
        if germline and hasattr(germline, 'pathogenic'):
            for gene in HRR_GENES | BER_GENES:
                if gene in germline.pathogenic:
                    if gene in HRR_GENES and gene not in hrr_mutated:
                        hrr_mutated.append(gene)
                    if gene in BER_GENES and gene not in ber_mutated:
                        ber_mutated.append(gene)
        
        # Determine status and mechanism
        all_mutated = hrr_mutated + ber_mutated
        
        if 'BRCA1' in all_mutated or 'BRCA2' in all_mutated:
            status = "HRD-INFERRED"
            mechanism = "BRCA_MUTATION"
            confidence = 0.90
        elif hrr_mutated:
            status = "HRD-INFERRED"
            mechanism = f"HRR_MUTATION_{hrr_mutated[0]}"
            confidence = 0.75
        elif ber_mutated:
            status = "HRD-INFERRED"
            mechanism = f"BER_DEFICIENCY_{ber_mutated[0]}"
            confidence = 0.70
        else:
            status = "unknown"
            mechanism = None
            confidence = 0.50
        
        return HRDResult(
            status=status,
            score=None,
            mechanism=mechanism,
            genes_mutated=all_mutated,
            genes_checked=list(HRR_GENES | BER_GENES),
            confidence=confidence
        )
```

### Constants

```python
# api/services/biomarkers/constants.py

# TMB Constants
TCGA_EXOME_SIZE_MB = 38.0
TMB_HIGH_THRESHOLD_PRIMARY = 10.0
TMB_HIGH_THRESHOLD_SECONDARY = 20.0

# Nonsynonymous mutation classifications
NONSYNONYMOUS_CLASSIFICATIONS = {
    'Missense_Mutation',
    'Nonsense_Mutation',
    'Frame_Shift_Del',
    'Frame_Shift_Ins',
    'In_Frame_Del',
    'In_Frame_Ins',
    'Splice_Site',
    'Translation_Start_Site',
    'Nonstop_Mutation'
}

# dMMR genes for MSI detection
DMMR_GENES = {'MLH1', 'MSH2', 'MSH6', 'PMS2', 'EPCAM'}

# Homologous Recombination Repair genes
HRR_GENES = {
    'BRCA1', 'BRCA2', 'ATM', 'ATR', 
    'CHEK1', 'CHEK2', 'RAD51C', 'RAD51D', 
    'PALB2', 'BARD1', 'BRIP1', 'FANCA', 
    'FANCD2', 'NBN', 'RAD51B'
}

# Base Excision Repair genes
BER_GENES = {
    'MBD4', 'MUTYH', 'OGG1', 'NTHL1', 
    'NEIL1', 'NEIL2', 'NEIL3', 'APEX1', 
    'XRCC1', 'PARP1', 'PARP2'
}
```

---

## ðŸ§ª TESTING

### TMB Validation Test

```python
# api/services/biomarkers/tests/test_tmb.py

import pytest
from ..tmb_calculator import TMBCalculator

@pytest.fixture
def calculator():
    return TMBCalculator()

def test_tmb_calculation_basic(calculator):
    mutations = [
        {'variant_classification': 'Missense_Mutation'},
        {'variant_classification': 'Missense_Mutation'},
        {'variant_classification': 'Frame_Shift_Del'},
    ]
    
    result = calculator.calculate(mutations, exome_size_mb=38.0)
    
    assert result.mutation_count == 3
    assert result.value == pytest.approx(3/38.0, rel=0.01)
    assert result.classification == "TMB-L"

def test_tmb_high_classification(calculator):
    # 380 mutations / 38 Mb = 10 mut/Mb = TMB-H
    mutations = [{'variant_classification': 'Missense_Mutation'}] * 380
    
    result = calculator.calculate(mutations)
    
    assert result.classification == "TMB-H"
    assert result.value >= 10.0

def test_tmb_skips_silent(calculator):
    mutations = [
        {'variant_classification': 'Missense_Mutation'},
        {'variant_classification': 'Silent'},  # Should be skipped
    ]
    
    result = calculator.calculate(mutations)
    
    assert result.mutation_count == 1
```

---

## ðŸ“‹ IMPLEMENTATION CHECKLIST

### Phase 1: TMB Calculator
- [ ] Port validated TMB code from `scripts/data_acquisition/utils/tmb_calculator.py`
- [ ] Add TMBResult dataclass
- [ ] Add validation provenance
- [ ] Unit tests matching TCGA validation

### Phase 2: MSI Detector
- [ ] Implement dMMR gene checking
- [ ] Handle germline results
- [ ] Add confidence scoring
- [ ] Unit tests

### Phase 3: HRD Inferrer
- [ ] Implement HRR gene checking
- [ ] Implement BER gene checking (MBD4)
- [ ] Support Myriad score input
- [ ] Mechanism identification
- [ ] Unit tests

### Phase 4: Integration
- [ ] Create BiomarkerAgent class
- [ ] Wire all calculators
- [ ] Add IO eligibility logic
- [ ] Add PARP eligibility logic
- [ ] Integration tests

---

## ðŸ“¡ API ENDPOINT

```yaml
POST /api/agents/biomarkers
Content-Type: application/json

Request:
  patient_id: string
  mutations: Mutation[]
  options:
    exome_size_mb: number  # default: 38.0
    tmb_threshold: number  # default: 10.0
    myriad_hrd_score: number  # optional

Response:
  biomarker_profile: BiomarkerProfile
  calculation_time_ms: number
```

---

## âœ… ACCEPTANCE CRITERIA

1. âœ… TMB calculation matches validated r=0.933 against TCGA
2. âœ… TMB-H classification at â‰¥10 mut/Mb
3. âœ… MSI detection from dMMR gene mutations
4. âœ… HRD inference from HRR/BER gene mutations
5. âœ… IO eligibility = TMB-H OR MSI-H
6. âœ… PARP eligibility = HRD+ or BRCA mutant
7. âœ… All results include validation provenance
8. âœ… Unit test coverage >80%

---

---

## ðŸŽ¯ MISSION

Build a biomarker calculation agent that can:
1. Calculate TMB from mutation list (validated r=0.933)
2. Detect MSI status from dMMR gene mutations
3. Infer HRD status from DNA repair gene mutations
4. Determine IO eligibility (TMB-H OR MSI-H)
5. Provide validation provenance for all calculations

---

## ðŸ“Š VALIDATED CAPABILITIES (USE THESE)

### TMB Calculation - ALREADY VALIDATED âœ…

**Location:** `scripts/data_acquisition/utils/tmb_calculator.py`

**Validation Metrics:**
| Metric | Value | Ground Truth |
|--------|-------|--------------|
| Pearson r | 0.933 | TCGA Pan-Immune |
| Classification Accuracy | 95.4% | n=1,895 patients |
| Sensitivity | 96.0% | TMB-H detection |
| Specificity | 95.2% | TMB-L detection |

**Key Code:**
```python
# From scripts/data_acquisition/utils/tmb_calculator.py
TCGA_EXOME_SIZE_MB = 38.0
TMB_HIGH_THRESHOLD = 10.0  # mutations per megabase

NONSYNONYMOUS_CLASSIFICATIONS = {
    'Missense_Mutation', 'Nonsense_Mutation', 'Frame_Shift_Del',
    'Frame_Shift_Ins', 'In_Frame_Del', 'In_Frame_Ins',
    'Splice_Site', 'Translation_Start_Site', 'Nonstop_Mutation'
}

def count_nonsynonymous_mutations(mutations: List[Dict]) -> int:
    """Count nonsynonymous mutations."""
    count = 0
    for mut in mutations:
        classification = mut.get("variant_classification", "").strip()
        protein_change = mut.get("hgvs_p", "") or mut.get("protein_change", "")
        
        if classification in NONSYNONYMOUS_CLASSIFICATIONS:
            count += 1
        elif protein_change and classification.upper() in ["SNP", "DEL", "INS"]:
            count += 1
    
    return count

def calculate_tmb(mutations: List[Dict], exome_size_mb: float = TCGA_EXOME_SIZE_MB) -> float:
    """Calculate TMB as mutations per megabase."""
    nonsynonymous_count = count_nonsynonymous_mutations(mutations)
    return nonsynonymous_count / exome_size_mb
```

---

## ðŸ“¥ INPUTS

### From PatientProfile (Module 01)

```python
@dataclass
class PatientProfile:
    patient_id: str
    disease: str
    mutations: List[Mutation]
    # ... other fields
```

---

## ðŸ“¤ OUTPUTS

### BiomarkerProfile Schema

```python
from dataclasses import dataclass
from typing import Optional, Dict, List
from enum import Enum

class TMBClassification(Enum):
    TMB_HIGH = "TMB-H"
    TMB_LOW = "TMB-L"
    UNKNOWN = "unknown"

class MSIStatus(Enum):
    MSI_HIGH = "MSI-H"
    MSI_LOW = "MSI-L"
    MSS = "MSS"
    UNKNOWN = "unknown"

class HRDStatus(Enum):
    HRD_POSITIVE = "HRD+"
    HRD_NEGATIVE = "HRD-"
    HRD_INFERRED = "HRD-INFERRED"
    UNKNOWN = "unknown"

@dataclass
class TMBResult:
    value: float                        # Mutations per Mb
    classification: TMBClassification
    threshold_used: float               # e.g., 10.0
    mutation_count: int                 # Total nonsynonymous
    exome_size_mb: float               # e.g., 38.0
    validation: Dict[str, any]         # Provenance

@dataclass
class MSIResult:
    status: MSIStatus
    dmmr_genes_mutated: List[str]      # e.g., ["MLH1", "MSH2"]
    dmmr_genes_checked: List[str]      # All genes checked
    method: str                         # "mutation_based" or "assay"
    confidence: float                   # 0.0 - 1.0

@dataclass
class HRDResult:
    status: HRDStatus
    score: Optional[float]              # If Myriad score available
    mechanism: Optional[str]            # e.g., "BRCA1_LOSS", "MBD4_BER"
    genes_mutated: List[str]            # HRR/BER genes mutated
    genes_checked: List[str]            # All genes checked
    confidence: float

@dataclass
class BiomarkerProfile:
    patient_id: str
    tmb: TMBResult
    msi: MSIResult
    hrd: HRDResult
    io_eligible: bool                   # TMB-H OR MSI-H
    io_eligibility_reason: str          # "TMB-H (12.3 mut/Mb)"
    parp_eligible: bool                 # HRD+ or BRCA mutant
    parp_eligibility_reason: str
    calculation_timestamp: datetime
    provenance: Dict[str, any]          # Full audit trail
```

---

## ðŸ—ï¸ IMPLEMENTATION

### File Structure

```
api/services/biomarkers/
â”œâ”€â”€ __init__.py
â”œâ”€â”€ biomarker_agent.py          # Main agent
â”œâ”€â”€ tmb_calculator.py           # TMB logic (port from validated)
â”œâ”€â”€ msi_detector.py             # MSI detection
â”œâ”€â”€ hrd_inferrer.py             # HRD inference
â”œâ”€â”€ io_eligibility.py           # IO eligibility determination
â”œâ”€â”€ constants.py                # Gene lists, thresholds
â””â”€â”€ tests/
    â”œâ”€â”€ test_tmb.py
    â”œâ”€â”€ test_msi.py
    â”œâ”€â”€ test_hrd.py
    â””â”€â”€ test_io_eligibility.py
```

### Core Agent Implementation

```python
# api/services/biomarkers/biomarker_agent.py

from typing import List
from datetime import datetime
import logging

from .tmb_calculator import TMBCalculator
from .msi_detector import MSIDetector
from .hrd_inferrer import HRDInferrer
from .io_eligibility import IOEligibilityChecker
from ..models import PatientProfile, BiomarkerProfile

logger = logging.getLogger(__name__)

class BiomarkerAgent:
    """
    Calculate all biomarkers from patient mutation data.
    
    Capabilities:
    - TMB (validated r=0.933 vs TCGA)
    - MSI (dMMR gene-based detection)
    - HRD (HRR/BER gene inference)
    - IO eligibility (TMB-H OR MSI-H)
    """
    
    def __init__(self):
        self.tmb_calculator = TMBCalculator()
        self.msi_detector = MSIDetector()
        self.hrd_inferrer = HRDInferrer()
        self.io_checker = IOEligibilityChecker()
    
    async def calculate(
        self,
        patient_profile: PatientProfile,
        options: dict = None
    ) -> BiomarkerProfile:
        """
        Calculate all biomarkers for a patient.
        
        Args:
            patient_profile: Patient data with mutations
            options: Optional config (thresholds, etc.)
        
        Returns:
            BiomarkerProfile with all calculated values
        """
        logger.info(f"Calculating biomarkers for {patient_profile.patient_id}")
        
        # Convert mutations to dict format for calculators
        mutations = self._mutations_to_dicts(patient_profile.mutations)
        
        # Step 1: Calculate TMB
        tmb_result = self.tmb_calculator.calculate(
            mutations=mutations,
            exome_size_mb=options.get('exome_size_mb', 38.0) if options else 38.0,
            threshold=options.get('tmb_threshold', 10.0) if options else 10.0
        )
        
        # Step 2: Detect MSI
        msi_result = self.msi_detector.detect(
            mutations=mutations,
            germline=patient_profile.germline_panel
        )
        
        # Step 3: Infer HRD
        hrd_result = self.hrd_inferrer.infer(
            mutations=mutations,
            germline=patient_profile.germline_panel,
            myriad_score=options.get('myriad_hrd_score') if options else None
        )
        
        # Step 4: Determine IO eligibility
        io_eligible, io_reason = self.io_checker.check(
            tmb_result=tmb_result,
            msi_result=msi_result
        )
        
        # Step 5: Determine PARP eligibility
        parp_eligible, parp_reason = self._check_parp_eligibility(hrd_result)
        
        # Build profile
        profile = BiomarkerProfile(
            patient_id=patient_profile.patient_id,
            tmb=tmb_result,
            msi=msi_result,
            hrd=hrd_result,
            io_eligible=io_eligible,
            io_eligibility_reason=io_reason,
            parp_eligible=parp_eligible,
            parp_eligibility_reason=parp_reason,
            calculation_timestamp=datetime.utcnow(),
            provenance={
                'tmb_validation': 'TCGA Pan-Immune r=0.933, n=1895',
                'msi_method': 'dMMR gene mutation detection',
                'hrd_method': 'HRR/BER gene inference'
            }
        )
        
        logger.info(
            f"Biomarkers: TMB={tmb_result.value:.2f}, "
            f"MSI={msi_result.status.value}, "
            f"HRD={hrd_result.status.value}, "
            f"IO={io_eligible}"
        )
        
        return profile
    
    def _mutations_to_dicts(self, mutations: List) -> List[dict]:
        """Convert Mutation objects to dicts for calculators."""
        return [
            {
                'gene': m.gene,
                'variant': m.variant,
                'hgvs_p': m.hgvs_p,
                'hgvs_c': m.hgvs_c,
                'variant_classification': m.classification,
                'protein_change': m.hgvs_p
            }
            for m in mutations
        ]
    
    def _check_parp_eligibility(self, hrd_result: HRDResult) -> tuple:
        """Check PARP inhibitor eligibility."""
        if hrd_result.status in [HRDStatus.HRD_POSITIVE, HRDStatus.HRD_INFERRED]:
            reason = f"{hrd_result.status.value}"
            if hrd_result.mechanism:
                reason += f" ({hrd_result.mechanism})"
            return True, reason
        
        return False, "HRD not detected"
```

### TMB Calculator

```python
# api/services/biomarkers/tmb_calculator.py

from typing import List, Dict
from dataclasses import dataclass
from .constants import NONSYNONYMOUS_CLASSIFICATIONS, TCGA_EXOME_SIZE_MB

@dataclass
class TMBResult:
    value: float
    classification: str
    threshold_used: float
    mutation_count: int
    exome_size_mb: float
    validation: Dict[str, any]

class TMBCalculator:
    """
    Calculate Tumor Mutational Burden.
    
    Validated against TCGA Pan-Immune publication:
    - Pearson r = 0.933
    - Classification accuracy = 95.4%
    """
    
    def calculate(
        self,
        mutations: List[Dict],
        exome_size_mb: float = TCGA_EXOME_SIZE_MB,
        threshold: float = 10.0
    ) -> TMBResult:
        """
        Calculate TMB from mutation list.
        
        Args:
            mutations: List of mutation dicts with variant_classification
            exome_size_mb: Exome size in megabases (default: 38.0)
            threshold: TMB-H threshold (default: 10.0 mut/Mb)
        
        Returns:
            TMBResult with value and classification
        """
        # Count nonsynonymous mutations
        count = self._count_nonsynonymous(mutations)
        
        # Calculate TMB
        tmb_value = count / exome_size_mb if exome_size_mb > 0 else 0.0
        
        # Classify
        classification = "TMB-H" if tmb_value >= threshold else "TMB-L"
        
        return TMBResult(
            value=round(tmb_value, 2),
            classification=classification,
            threshold_used=threshold,
            mutation_count=count,
            exome_size_mb=exome_size_mb,
            validation={
                'method': 'nonsynonymous_count / exome_size',
                'ground_truth': 'TCGA Pan-Immune',
                'pearson_r': 0.933,
                'accuracy': 0.954,
                'n_validated': 1895
            }
        )
    
    def _count_nonsynonymous(self, mutations: List[Dict]) -> int:
        """Count nonsynonymous mutations."""
        count = 0
        for mut in mutations:
            classification = mut.get("variant_classification", "").strip()
            protein_change = mut.get("hgvs_p", "") or mut.get("protein_change", "")
            
            # Check standard MAF classifications
            if classification in NONSYNONYMOUS_CLASSIFICATIONS:
                count += 1
                continue
            
            # Handle simplified classifications (SNP, DEL, INS)
            if protein_change and protein_change.strip():
                if "=" in protein_change or protein_change.endswith("="):
                    continue  # Silent mutation
                if classification.upper() in ["SNP", "DEL", "INS", "ONP"]:
                    count += 1
        
        return count
```

### MSI Detector

```python
# api/services/biomarkers/msi_detector.py

from typing import List, Dict, Optional
from dataclasses import dataclass
from .constants import DMMR_GENES

@dataclass
class MSIResult:
    status: str
    dmmr_genes_mutated: List[str]
    dmmr_genes_checked: List[str]
    method: str
    confidence: float

class MSIDetector:
    """
    Detect Microsatellite Instability from dMMR gene mutations.
    
    dMMR genes: MLH1, MSH2, MSH6, PMS2, EPCAM
    """
    
    def detect(
        self,
        mutations: List[Dict],
        germline: Optional[dict] = None
    ) -> MSIResult:
        """
        Detect MSI status from dMMR gene mutations.
        
        Args:
            mutations: Somatic mutations
            germline: Optional germline panel results
        
        Returns:
            MSIResult with status and details
        """
        # Get mutated genes
        mutated_genes = {m.get('gene', '').upper() for m in mutations}
        
        # Check dMMR genes
        dmmr_mutated = []
        for gene in DMMR_GENES:
            if gene in mutated_genes:
                dmmr_mutated.append(gene)
        
        # Also check germline if available
        if germline and hasattr(germline, 'pathogenic'):
            for gene in DMMR_GENES:
                if gene in germline.pathogenic:
                    if gene not in dmmr_mutated:
                        dmmr_mutated.append(gene)
        
        # Determine status
        if len(dmmr_mutated) >= 1:
            status = "MSI-H"
            confidence = 0.85 if len(dmmr_mutated) >= 2 else 0.70
        else:
            status = "MSS"
            confidence = 0.80  # Lower confidence without assay
        
        return MSIResult(
            status=status,
            dmmr_genes_mutated=dmmr_mutated,
            dmmr_genes_checked=list(DMMR_GENES),
            method="mutation_based",
            confidence=confidence
        )
```

### HRD Inferrer

```python
# api/services/biomarkers/hrd_inferrer.py

from typing import List, Dict, Optional
from dataclasses import dataclass
from .constants import HRR_GENES, BER_GENES

@dataclass
class HRDResult:
    status: str
    score: Optional[float]
    mechanism: Optional[str]
    genes_mutated: List[str]
    genes_checked: List[str]
    confidence: float

class HRDInferrer:
    """
    Infer Homologous Recombination Deficiency from DNA repair gene mutations.
    
    HRR genes: BRCA1, BRCA2, ATM, ATR, CHEK1, CHEK2, RAD51C, RAD51D, PALB2, BARD1
    BER genes: MBD4, MUTYH, OGG1, NTHL1, NEIL1
    """
    
    def infer(
        self,
        mutations: List[Dict],
        germline: Optional[dict] = None,
        myriad_score: Optional[float] = None
    ) -> HRDResult:
        """
        Infer HRD status from DNA repair gene mutations.
        
        Args:
            mutations: Somatic mutations
            germline: Optional germline panel
            myriad_score: Optional Myriad HRD score (â‰¥42 = HRD+)
        
        Returns:
            HRDResult with status and mechanism
        """
        # If we have Myriad score, use it directly
        if myriad_score is not None:
            status = "HRD+" if myriad_score >= 42 else "HRD-"
            return HRDResult(
                status=status,
                score=myriad_score,
                mechanism="myriad_score",
                genes_mutated=[],
                genes_checked=list(HRR_GENES | BER_GENES),
                confidence=0.95
            )
        
        # Otherwise, infer from mutations
        mutated_genes = {m.get('gene', '').upper() for m in mutations}
        
        # Check HRR genes
        hrr_mutated = [g for g in HRR_GENES if g in mutated_genes]
        
        # Check BER genes
        ber_mutated = [g for g in BER_GENES if g in mutated_genes]
        
        # Check germline
        if germline and hasattr(germline, 'pathogenic'):
            for gene in HRR_GENES | BER_GENES:
                if gene in germline.pathogenic:
                    if gene in HRR_GENES and gene not in hrr_mutated:
                        hrr_mutated.append(gene)
                    if gene in BER_GENES and gene not in ber_mutated:
                        ber_mutated.append(gene)
        
        # Determine status and mechanism
        all_mutated = hrr_mutated + ber_mutated
        
        if 'BRCA1' in all_mutated or 'BRCA2' in all_mutated:
            status = "HRD-INFERRED"
            mechanism = "BRCA_MUTATION"
            confidence = 0.90
        elif hrr_mutated:
            status = "HRD-INFERRED"
            mechanism = f"HRR_MUTATION_{hrr_mutated[0]}"
            confidence = 0.75
        elif ber_mutated:
            status = "HRD-INFERRED"
            mechanism = f"BER_DEFICIENCY_{ber_mutated[0]}"
            confidence = 0.70
        else:
            status = "unknown"
            mechanism = None
            confidence = 0.50
        
        return HRDResult(
            status=status,
            score=None,
            mechanism=mechanism,
            genes_mutated=all_mutated,
            genes_checked=list(HRR_GENES | BER_GENES),
            confidence=confidence
        )
```

### Constants

```python
# api/services/biomarkers/constants.py

# TMB Constants
TCGA_EXOME_SIZE_MB = 38.0
TMB_HIGH_THRESHOLD_PRIMARY = 10.0
TMB_HIGH_THRESHOLD_SECONDARY = 20.0

# Nonsynonymous mutation classifications
NONSYNONYMOUS_CLASSIFICATIONS = {
    'Missense_Mutation',
    'Nonsense_Mutation',
    'Frame_Shift_Del',
    'Frame_Shift_Ins',
    'In_Frame_Del',
    'In_Frame_Ins',
    'Splice_Site',
    'Translation_Start_Site',
    'Nonstop_Mutation'
}

# dMMR genes for MSI detection
DMMR_GENES = {'MLH1', 'MSH2', 'MSH6', 'PMS2', 'EPCAM'}

# Homologous Recombination Repair genes
HRR_GENES = {
    'BRCA1', 'BRCA2', 'ATM', 'ATR', 
    'CHEK1', 'CHEK2', 'RAD51C', 'RAD51D', 
    'PALB2', 'BARD1', 'BRIP1', 'FANCA', 
    'FANCD2', 'NBN', 'RAD51B'
}

# Base Excision Repair genes
BER_GENES = {
    'MBD4', 'MUTYH', 'OGG1', 'NTHL1', 
    'NEIL1', 'NEIL2', 'NEIL3', 'APEX1', 
    'XRCC1', 'PARP1', 'PARP2'
}
```

---

## ðŸ§ª TESTING

### TMB Validation Test

```python
# api/services/biomarkers/tests/test_tmb.py

import pytest
from ..tmb_calculator import TMBCalculator

@pytest.fixture
def calculator():
    return TMBCalculator()

def test_tmb_calculation_basic(calculator):
    mutations = [
        {'variant_classification': 'Missense_Mutation'},
        {'variant_classification': 'Missense_Mutation'},
        {'variant_classification': 'Frame_Shift_Del'},
    ]
    
    result = calculator.calculate(mutations, exome_size_mb=38.0)
    
    assert result.mutation_count == 3
    assert result.value == pytest.approx(3/38.0, rel=0.01)
    assert result.classification == "TMB-L"

def test_tmb_high_classification(calculator):
    # 380 mutations / 38 Mb = 10 mut/Mb = TMB-H
    mutations = [{'variant_classification': 'Missense_Mutation'}] * 380
    
    result = calculator.calculate(mutations)
    
    assert result.classification == "TMB-H"
    assert result.value >= 10.0

def test_tmb_skips_silent(calculator):
    mutations = [
        {'variant_classification': 'Missense_Mutation'},
        {'variant_classification': 'Silent'},  # Should be skipped
    ]
    
    result = calculator.calculate(mutations)
    
    assert result.mutation_count == 1
```

---

## ðŸ“‹ IMPLEMENTATION CHECKLIST

### Phase 1: TMB Calculator
- [ ] Port validated TMB code from `scripts/data_acquisition/utils/tmb_calculator.py`
- [ ] Add TMBResult dataclass
- [ ] Add validation provenance
- [ ] Unit tests matching TCGA validation

### Phase 2: MSI Detector
- [ ] Implement dMMR gene checking
- [ ] Handle germline results
- [ ] Add confidence scoring
- [ ] Unit tests

### Phase 3: HRD Inferrer
- [ ] Implement HRR gene checking
- [ ] Implement BER gene checking (MBD4)
- [ ] Support Myriad score input
- [ ] Mechanism identification
- [ ] Unit tests

### Phase 4: Integration
- [ ] Create BiomarkerAgent class
- [ ] Wire all calculators
- [ ] Add IO eligibility logic
- [ ] Add PARP eligibility logic
- [ ] Integration tests

---

## ðŸ“¡ API ENDPOINT

```yaml
POST /api/agents/biomarkers
Content-Type: application/json

Request:
  patient_id: string
  mutations: Mutation[]
  options:
    exome_size_mb: number  # default: 38.0
    tmb_threshold: number  # default: 10.0
    myriad_hrd_score: number  # optional

Response:
  biomarker_profile: BiomarkerProfile
  calculation_time_ms: number
```

---

## âœ… ACCEPTANCE CRITERIA

1. âœ… TMB calculation matches validated r=0.933 against TCGA
2. âœ… TMB-H classification at â‰¥10 mut/Mb
3. âœ… MSI detection from dMMR gene mutations
4. âœ… HRD inference from HRR/BER gene mutations
5. âœ… IO eligibility = TMB-H OR MSI-H
6. âœ… PARP eligibility = HRD+ or BRCA mutant
7. âœ… All results include validation provenance
8. âœ… Unit test coverage >80%

---

---

## ðŸŽ¯ MISSION

Build a biomarker calculation agent that can:
1. Calculate TMB from mutation list (validated r=0.933)
2. Detect MSI status from dMMR gene mutations
3. Infer HRD status from DNA repair gene mutations
4. Determine IO eligibility (TMB-H OR MSI-H)
5. Provide validation provenance for all calculations

---

## ðŸ“Š VALIDATED CAPABILITIES (USE THESE)

### TMB Calculation - ALREADY VALIDATED âœ…

**Location:** `scripts/data_acquisition/utils/tmb_calculator.py`

**Validation Metrics:**
| Metric | Value | Ground Truth |
|--------|-------|--------------|
| Pearson r | 0.933 | TCGA Pan-Immune |
| Classification Accuracy | 95.4% | n=1,895 patients |
| Sensitivity | 96.0% | TMB-H detection |
| Specificity | 95.2% | TMB-L detection |

**Key Code:**
```python
# From scripts/data_acquisition/utils/tmb_calculator.py
TCGA_EXOME_SIZE_MB = 38.0
TMB_HIGH_THRESHOLD = 10.0  # mutations per megabase

NONSYNONYMOUS_CLASSIFICATIONS = {
    'Missense_Mutation', 'Nonsense_Mutation', 'Frame_Shift_Del',
    'Frame_Shift_Ins', 'In_Frame_Del', 'In_Frame_Ins',
    'Splice_Site', 'Translation_Start_Site', 'Nonstop_Mutation'
}

def count_nonsynonymous_mutations(mutations: List[Dict]) -> int:
    """Count nonsynonymous mutations."""
    count = 0
    for mut in mutations:
        classification = mut.get("variant_classification", "").strip()
        protein_change = mut.get("hgvs_p", "") or mut.get("protein_change", "")
        
        if classification in NONSYNONYMOUS_CLASSIFICATIONS:
            count += 1
        elif protein_change and classification.upper() in ["SNP", "DEL", "INS"]:
            count += 1
    
    return count

def calculate_tmb(mutations: List[Dict], exome_size_mb: float = TCGA_EXOME_SIZE_MB) -> float:
    """Calculate TMB as mutations per megabase."""
    nonsynonymous_count = count_nonsynonymous_mutations(mutations)
    return nonsynonymous_count / exome_size_mb
```

---

## ðŸ“¥ INPUTS

### From PatientProfile (Module 01)

```python
@dataclass
class PatientProfile:
    patient_id: str
    disease: str
    mutations: List[Mutation]
    # ... other fields
```

---

## ðŸ“¤ OUTPUTS

### BiomarkerProfile Schema

```python
from dataclasses import dataclass
from typing import Optional, Dict, List
from enum import Enum

class TMBClassification(Enum):
    TMB_HIGH = "TMB-H"
    TMB_LOW = "TMB-L"
    UNKNOWN = "unknown"

class MSIStatus(Enum):
    MSI_HIGH = "MSI-H"
    MSI_LOW = "MSI-L"
    MSS = "MSS"
    UNKNOWN = "unknown"

class HRDStatus(Enum):
    HRD_POSITIVE = "HRD+"
    HRD_NEGATIVE = "HRD-"
    HRD_INFERRED = "HRD-INFERRED"
    UNKNOWN = "unknown"

@dataclass
class TMBResult:
    value: float                        # Mutations per Mb
    classification: TMBClassification
    threshold_used: float               # e.g., 10.0
    mutation_count: int                 # Total nonsynonymous
    exome_size_mb: float               # e.g., 38.0
    validation: Dict[str, any]         # Provenance

@dataclass
class MSIResult:
    status: MSIStatus
    dmmr_genes_mutated: List[str]      # e.g., ["MLH1", "MSH2"]
    dmmr_genes_checked: List[str]      # All genes checked
    method: str                         # "mutation_based" or "assay"
    confidence: float                   # 0.0 - 1.0

@dataclass
class HRDResult:
    status: HRDStatus
    score: Optional[float]              # If Myriad score available
    mechanism: Optional[str]            # e.g., "BRCA1_LOSS", "MBD4_BER"
    genes_mutated: List[str]            # HRR/BER genes mutated
    genes_checked: List[str]            # All genes checked
    confidence: float

@dataclass
class BiomarkerProfile:
    patient_id: str
    tmb: TMBResult
    msi: MSIResult
    hrd: HRDResult
    io_eligible: bool                   # TMB-H OR MSI-H
    io_eligibility_reason: str          # "TMB-H (12.3 mut/Mb)"
    parp_eligible: bool                 # HRD+ or BRCA mutant
    parp_eligibility_reason: str
    calculation_timestamp: datetime
    provenance: Dict[str, any]          # Full audit trail
```

---

## ðŸ—ï¸ IMPLEMENTATION

### File Structure

```
api/services/biomarkers/
â”œâ”€â”€ __init__.py
â”œâ”€â”€ biomarker_agent.py          # Main agent
â”œâ”€â”€ tmb_calculator.py           # TMB logic (port from validated)
â”œâ”€â”€ msi_detector.py             # MSI detection
â”œâ”€â”€ hrd_inferrer.py             # HRD inference
â”œâ”€â”€ io_eligibility.py           # IO eligibility determination
â”œâ”€â”€ constants.py                # Gene lists, thresholds
â””â”€â”€ tests/
    â”œâ”€â”€ test_tmb.py
    â”œâ”€â”€ test_msi.py
    â”œâ”€â”€ test_hrd.py
    â””â”€â”€ test_io_eligibility.py
```

### Core Agent Implementation

```python
# api/services/biomarkers/biomarker_agent.py

from typing import List
from datetime import datetime
import logging

from .tmb_calculator import TMBCalculator
from .msi_detector import MSIDetector
from .hrd_inferrer import HRDInferrer
from .io_eligibility import IOEligibilityChecker
from ..models import PatientProfile, BiomarkerProfile

logger = logging.getLogger(__name__)

class BiomarkerAgent:
    """
    Calculate all biomarkers from patient mutation data.
    
    Capabilities:
    - TMB (validated r=0.933 vs TCGA)
    - MSI (dMMR gene-based detection)
    - HRD (HRR/BER gene inference)
    - IO eligibility (TMB-H OR MSI-H)
    """
    
    def __init__(self):
        self.tmb_calculator = TMBCalculator()
        self.msi_detector = MSIDetector()
        self.hrd_inferrer = HRDInferrer()
        self.io_checker = IOEligibilityChecker()
    
    async def calculate(
        self,
        patient_profile: PatientProfile,
        options: dict = None
    ) -> BiomarkerProfile:
        """
        Calculate all biomarkers for a patient.
        
        Args:
            patient_profile: Patient data with mutations
            options: Optional config (thresholds, etc.)
        
        Returns:
            BiomarkerProfile with all calculated values
        """
        logger.info(f"Calculating biomarkers for {patient_profile.patient_id}")
        
        # Convert mutations to dict format for calculators
        mutations = self._mutations_to_dicts(patient_profile.mutations)
        
        # Step 1: Calculate TMB
        tmb_result = self.tmb_calculator.calculate(
            mutations=mutations,
            exome_size_mb=options.get('exome_size_mb', 38.0) if options else 38.0,
            threshold=options.get('tmb_threshold', 10.0) if options else 10.0
        )
        
        # Step 2: Detect MSI
        msi_result = self.msi_detector.detect(
            mutations=mutations,
            germline=patient_profile.germline_panel
        )
        
        # Step 3: Infer HRD
        hrd_result = self.hrd_inferrer.infer(
            mutations=mutations,
            germline=patient_profile.germline_panel,
            myriad_score=options.get('myriad_hrd_score') if options else None
        )
        
        # Step 4: Determine IO eligibility
        io_eligible, io_reason = self.io_checker.check(
            tmb_result=tmb_result,
            msi_result=msi_result
        )
        
        # Step 5: Determine PARP eligibility
        parp_eligible, parp_reason = self._check_parp_eligibility(hrd_result)
        
        # Build profile
        profile = BiomarkerProfile(
            patient_id=patient_profile.patient_id,
            tmb=tmb_result,
            msi=msi_result,
            hrd=hrd_result,
            io_eligible=io_eligible,
            io_eligibility_reason=io_reason,
            parp_eligible=parp_eligible,
            parp_eligibility_reason=parp_reason,
            calculation_timestamp=datetime.utcnow(),
            provenance={
                'tmb_validation': 'TCGA Pan-Immune r=0.933, n=1895',
                'msi_method': 'dMMR gene mutation detection',
                'hrd_method': 'HRR/BER gene inference'
            }
        )
        
        logger.info(
            f"Biomarkers: TMB={tmb_result.value:.2f}, "
            f"MSI={msi_result.status.value}, "
            f"HRD={hrd_result.status.value}, "
            f"IO={io_eligible}"
        )
        
        return profile
    
    def _mutations_to_dicts(self, mutations: List) -> List[dict]:
        """Convert Mutation objects to dicts for calculators."""
        return [
            {
                'gene': m.gene,
                'variant': m.variant,
                'hgvs_p': m.hgvs_p,
                'hgvs_c': m.hgvs_c,
                'variant_classification': m.classification,
                'protein_change': m.hgvs_p
            }
            for m in mutations
        ]
    
    def _check_parp_eligibility(self, hrd_result: HRDResult) -> tuple:
        """Check PARP inhibitor eligibility."""
        if hrd_result.status in [HRDStatus.HRD_POSITIVE, HRDStatus.HRD_INFERRED]:
            reason = f"{hrd_result.status.value}"
            if hrd_result.mechanism:
                reason += f" ({hrd_result.mechanism})"
            return True, reason
        
        return False, "HRD not detected"
```

### TMB Calculator

```python
# api/services/biomarkers/tmb_calculator.py

from typing import List, Dict
from dataclasses import dataclass
from .constants import NONSYNONYMOUS_CLASSIFICATIONS, TCGA_EXOME_SIZE_MB

@dataclass
class TMBResult:
    value: float
    classification: str
    threshold_used: float
    mutation_count: int
    exome_size_mb: float
    validation: Dict[str, any]

class TMBCalculator:
    """
    Calculate Tumor Mutational Burden.
    
    Validated against TCGA Pan-Immune publication:
    - Pearson r = 0.933
    - Classification accuracy = 95.4%
    """
    
    def calculate(
        self,
        mutations: List[Dict],
        exome_size_mb: float = TCGA_EXOME_SIZE_MB,
        threshold: float = 10.0
    ) -> TMBResult:
        """
        Calculate TMB from mutation list.
        
        Args:
            mutations: List of mutation dicts with variant_classification
            exome_size_mb: Exome size in megabases (default: 38.0)
            threshold: TMB-H threshold (default: 10.0 mut/Mb)
        
        Returns:
            TMBResult with value and classification
        """
        # Count nonsynonymous mutations
        count = self._count_nonsynonymous(mutations)
        
        # Calculate TMB
        tmb_value = count / exome_size_mb if exome_size_mb > 0 else 0.0
        
        # Classify
        classification = "TMB-H" if tmb_value >= threshold else "TMB-L"
        
        return TMBResult(
            value=round(tmb_value, 2),
            classification=classification,
            threshold_used=threshold,
            mutation_count=count,
            exome_size_mb=exome_size_mb,
            validation={
                'method': 'nonsynonymous_count / exome_size',
                'ground_truth': 'TCGA Pan-Immune',
                'pearson_r': 0.933,
                'accuracy': 0.954,
                'n_validated': 1895
            }
        )
    
    def _count_nonsynonymous(self, mutations: List[Dict]) -> int:
        """Count nonsynonymous mutations."""
        count = 0
        for mut in mutations:
            classification = mut.get("variant_classification", "").strip()
            protein_change = mut.get("hgvs_p", "") or mut.get("protein_change", "")
            
            # Check standard MAF classifications
            if classification in NONSYNONYMOUS_CLASSIFICATIONS:
                count += 1
                continue
            
            # Handle simplified classifications (SNP, DEL, INS)
            if protein_change and protein_change.strip():
                if "=" in protein_change or protein_change.endswith("="):
                    continue  # Silent mutation
                if classification.upper() in ["SNP", "DEL", "INS", "ONP"]:
                    count += 1
        
        return count
```

### MSI Detector

```python
# api/services/biomarkers/msi_detector.py

from typing import List, Dict, Optional
from dataclasses import dataclass
from .constants import DMMR_GENES

@dataclass
class MSIResult:
    status: str
    dmmr_genes_mutated: List[str]
    dmmr_genes_checked: List[str]
    method: str
    confidence: float

class MSIDetector:
    """
    Detect Microsatellite Instability from dMMR gene mutations.
    
    dMMR genes: MLH1, MSH2, MSH6, PMS2, EPCAM
    """
    
    def detect(
        self,
        mutations: List[Dict],
        germline: Optional[dict] = None
    ) -> MSIResult:
        """
        Detect MSI status from dMMR gene mutations.
        
        Args:
            mutations: Somatic mutations
            germline: Optional germline panel results
        
        Returns:
            MSIResult with status and details
        """
        # Get mutated genes
        mutated_genes = {m.get('gene', '').upper() for m in mutations}
        
        # Check dMMR genes
        dmmr_mutated = []
        for gene in DMMR_GENES:
            if gene in mutated_genes:
                dmmr_mutated.append(gene)
        
        # Also check germline if available
        if germline and hasattr(germline, 'pathogenic'):
            for gene in DMMR_GENES:
                if gene in germline.pathogenic:
                    if gene not in dmmr_mutated:
                        dmmr_mutated.append(gene)
        
        # Determine status
        if len(dmmr_mutated) >= 1:
            status = "MSI-H"
            confidence = 0.85 if len(dmmr_mutated) >= 2 else 0.70
        else:
            status = "MSS"
            confidence = 0.80  # Lower confidence without assay
        
        return MSIResult(
            status=status,
            dmmr_genes_mutated=dmmr_mutated,
            dmmr_genes_checked=list(DMMR_GENES),
            method="mutation_based",
            confidence=confidence
        )
```

### HRD Inferrer

```python
# api/services/biomarkers/hrd_inferrer.py

from typing import List, Dict, Optional
from dataclasses import dataclass
from .constants import HRR_GENES, BER_GENES

@dataclass
class HRDResult:
    status: str
    score: Optional[float]
    mechanism: Optional[str]
    genes_mutated: List[str]
    genes_checked: List[str]
    confidence: float

class HRDInferrer:
    """
    Infer Homologous Recombination Deficiency from DNA repair gene mutations.
    
    HRR genes: BRCA1, BRCA2, ATM, ATR, CHEK1, CHEK2, RAD51C, RAD51D, PALB2, BARD1
    BER genes: MBD4, MUTYH, OGG1, NTHL1, NEIL1
    """
    
    def infer(
        self,
        mutations: List[Dict],
        germline: Optional[dict] = None,
        myriad_score: Optional[float] = None
    ) -> HRDResult:
        """
        Infer HRD status from DNA repair gene mutations.
        
        Args:
            mutations: Somatic mutations
            germline: Optional germline panel
            myriad_score: Optional Myriad HRD score (â‰¥42 = HRD+)
        
        Returns:
            HRDResult with status and mechanism
        """
        # If we have Myriad score, use it directly
        if myriad_score is not None:
            status = "HRD+" if myriad_score >= 42 else "HRD-"
            return HRDResult(
                status=status,
                score=myriad_score,
                mechanism="myriad_score",
                genes_mutated=[],
                genes_checked=list(HRR_GENES | BER_GENES),
                confidence=0.95
            )
        
        # Otherwise, infer from mutations
        mutated_genes = {m.get('gene', '').upper() for m in mutations}
        
        # Check HRR genes
        hrr_mutated = [g for g in HRR_GENES if g in mutated_genes]
        
        # Check BER genes
        ber_mutated = [g for g in BER_GENES if g in mutated_genes]
        
        # Check germline
        if germline and hasattr(germline, 'pathogenic'):
            for gene in HRR_GENES | BER_GENES:
                if gene in germline.pathogenic:
                    if gene in HRR_GENES and gene not in hrr_mutated:
                        hrr_mutated.append(gene)
                    if gene in BER_GENES and gene not in ber_mutated:
                        ber_mutated.append(gene)
        
        # Determine status and mechanism
        all_mutated = hrr_mutated + ber_mutated
        
        if 'BRCA1' in all_mutated or 'BRCA2' in all_mutated:
            status = "HRD-INFERRED"
            mechanism = "BRCA_MUTATION"
            confidence = 0.90
        elif hrr_mutated:
            status = "HRD-INFERRED"
            mechanism = f"HRR_MUTATION_{hrr_mutated[0]}"
            confidence = 0.75
        elif ber_mutated:
            status = "HRD-INFERRED"
            mechanism = f"BER_DEFICIENCY_{ber_mutated[0]}"
            confidence = 0.70
        else:
            status = "unknown"
            mechanism = None
            confidence = 0.50
        
        return HRDResult(
            status=status,
            score=None,
            mechanism=mechanism,
            genes_mutated=all_mutated,
            genes_checked=list(HRR_GENES | BER_GENES),
            confidence=confidence
        )
```

### Constants

```python
# api/services/biomarkers/constants.py

# TMB Constants
TCGA_EXOME_SIZE_MB = 38.0
TMB_HIGH_THRESHOLD_PRIMARY = 10.0
TMB_HIGH_THRESHOLD_SECONDARY = 20.0

# Nonsynonymous mutation classifications
NONSYNONYMOUS_CLASSIFICATIONS = {
    'Missense_Mutation',
    'Nonsense_Mutation',
    'Frame_Shift_Del',
    'Frame_Shift_Ins',
    'In_Frame_Del',
    'In_Frame_Ins',
    'Splice_Site',
    'Translation_Start_Site',
    'Nonstop_Mutation'
}

# dMMR genes for MSI detection
DMMR_GENES = {'MLH1', 'MSH2', 'MSH6', 'PMS2', 'EPCAM'}

# Homologous Recombination Repair genes
HRR_GENES = {
    'BRCA1', 'BRCA2', 'ATM', 'ATR', 
    'CHEK1', 'CHEK2', 'RAD51C', 'RAD51D', 
    'PALB2', 'BARD1', 'BRIP1', 'FANCA', 
    'FANCD2', 'NBN', 'RAD51B'
}

# Base Excision Repair genes
BER_GENES = {
    'MBD4', 'MUTYH', 'OGG1', 'NTHL1', 
    'NEIL1', 'NEIL2', 'NEIL3', 'APEX1', 
    'XRCC1', 'PARP1', 'PARP2'
}
```

---

## ðŸ§ª TESTING

### TMB Validation Test

```python
# api/services/biomarkers/tests/test_tmb.py

import pytest
from ..tmb_calculator import TMBCalculator

@pytest.fixture
def calculator():
    return TMBCalculator()

def test_tmb_calculation_basic(calculator):
    mutations = [
        {'variant_classification': 'Missense_Mutation'},
        {'variant_classification': 'Missense_Mutation'},
        {'variant_classification': 'Frame_Shift_Del'},
    ]
    
    result = calculator.calculate(mutations, exome_size_mb=38.0)
    
    assert result.mutation_count == 3
    assert result.value == pytest.approx(3/38.0, rel=0.01)
    assert result.classification == "TMB-L"

def test_tmb_high_classification(calculator):
    # 380 mutations / 38 Mb = 10 mut/Mb = TMB-H
    mutations = [{'variant_classification': 'Missense_Mutation'}] * 380
    
    result = calculator.calculate(mutations)
    
    assert result.classification == "TMB-H"
    assert result.value >= 10.0

def test_tmb_skips_silent(calculator):
    mutations = [
        {'variant_classification': 'Missense_Mutation'},
        {'variant_classification': 'Silent'},  # Should be skipped
    ]
    
    result = calculator.calculate(mutations)
    
    assert result.mutation_count == 1
```

---

## ðŸ“‹ IMPLEMENTATION CHECKLIST

### Phase 1: TMB Calculator
- [ ] Port validated TMB code from `scripts/data_acquisition/utils/tmb_calculator.py`
- [ ] Add TMBResult dataclass
- [ ] Add validation provenance
- [ ] Unit tests matching TCGA validation

### Phase 2: MSI Detector
- [ ] Implement dMMR gene checking
- [ ] Handle germline results
- [ ] Add confidence scoring
- [ ] Unit tests

### Phase 3: HRD Inferrer
- [ ] Implement HRR gene checking
- [ ] Implement BER gene checking (MBD4)
- [ ] Support Myriad score input
- [ ] Mechanism identification
- [ ] Unit tests

### Phase 4: Integration
- [ ] Create BiomarkerAgent class
- [ ] Wire all calculators
- [ ] Add IO eligibility logic
- [ ] Add PARP eligibility logic
- [ ] Integration tests

---

## ðŸ“¡ API ENDPOINT

```yaml
POST /api/agents/biomarkers
Content-Type: application/json

Request:
  patient_id: string
  mutations: Mutation[]
  options:
    exome_size_mb: number  # default: 38.0
    tmb_threshold: number  # default: 10.0
    myriad_hrd_score: number  # optional

Response:
  biomarker_profile: BiomarkerProfile
  calculation_time_ms: number
```

---

## âœ… ACCEPTANCE CRITERIA

1. âœ… TMB calculation matches validated r=0.933 against TCGA
2. âœ… TMB-H classification at â‰¥10 mut/Mb
3. âœ… MSI detection from dMMR gene mutations
4. âœ… HRD inference from HRR/BER gene mutations
5. âœ… IO eligibility = TMB-H OR MSI-H
6. âœ… PARP eligibility = HRD+ or BRCA mutant
7. âœ… All results include validation provenance
8. âœ… Unit test coverage >80%

---

---

## ðŸŽ¯ MISSION

Build a biomarker calculation agent that can:
1. Calculate TMB from mutation list (validated r=0.933)
2. Detect MSI status from dMMR gene mutations
3. Infer HRD status from DNA repair gene mutations
4. Determine IO eligibility (TMB-H OR MSI-H)
5. Provide validation provenance for all calculations

---

## ðŸ“Š VALIDATED CAPABILITIES (USE THESE)

### TMB Calculation - ALREADY VALIDATED âœ…

**Location:** `scripts/data_acquisition/utils/tmb_calculator.py`

**Validation Metrics:**
| Metric | Value | Ground Truth |
|--------|-------|--------------|
| Pearson r | 0.933 | TCGA Pan-Immune |
| Classification Accuracy | 95.4% | n=1,895 patients |
| Sensitivity | 96.0% | TMB-H detection |
| Specificity | 95.2% | TMB-L detection |

**Key Code:**
```python
# From scripts/data_acquisition/utils/tmb_calculator.py
TCGA_EXOME_SIZE_MB = 38.0
TMB_HIGH_THRESHOLD = 10.0  # mutations per megabase

NONSYNONYMOUS_CLASSIFICATIONS = {
    'Missense_Mutation', 'Nonsense_Mutation', 'Frame_Shift_Del',
    'Frame_Shift_Ins', 'In_Frame_Del', 'In_Frame_Ins',
    'Splice_Site', 'Translation_Start_Site', 'Nonstop_Mutation'
}

def count_nonsynonymous_mutations(mutations: List[Dict]) -> int:
    """Count nonsynonymous mutations."""
    count = 0
    for mut in mutations:
        classification = mut.get("variant_classification", "").strip()
        protein_change = mut.get("hgvs_p", "") or mut.get("protein_change", "")
        
        if classification in NONSYNONYMOUS_CLASSIFICATIONS:
            count += 1
        elif protein_change and classification.upper() in ["SNP", "DEL", "INS"]:
            count += 1
    
    return count

def calculate_tmb(mutations: List[Dict], exome_size_mb: float = TCGA_EXOME_SIZE_MB) -> float:
    """Calculate TMB as mutations per megabase."""
    nonsynonymous_count = count_nonsynonymous_mutations(mutations)
    return nonsynonymous_count / exome_size_mb
```

---

## ðŸ“¥ INPUTS

### From PatientProfile (Module 01)

```python
@dataclass
class PatientProfile:
    patient_id: str
    disease: str
    mutations: List[Mutation]
    # ... other fields
```

---

## ðŸ“¤ OUTPUTS

### BiomarkerProfile Schema

```python
from dataclasses import dataclass
from typing import Optional, Dict, List
from enum import Enum

class TMBClassification(Enum):
    TMB_HIGH = "TMB-H"
    TMB_LOW = "TMB-L"
    UNKNOWN = "unknown"

class MSIStatus(Enum):
    MSI_HIGH = "MSI-H"
    MSI_LOW = "MSI-L"
    MSS = "MSS"
    UNKNOWN = "unknown"

class HRDStatus(Enum):
    HRD_POSITIVE = "HRD+"
    HRD_NEGATIVE = "HRD-"
    HRD_INFERRED = "HRD-INFERRED"
    UNKNOWN = "unknown"

@dataclass
class TMBResult:
    value: float                        # Mutations per Mb
    classification: TMBClassification
    threshold_used: float               # e.g., 10.0
    mutation_count: int                 # Total nonsynonymous
    exome_size_mb: float               # e.g., 38.0
    validation: Dict[str, any]         # Provenance

@dataclass
class MSIResult:
    status: MSIStatus
    dmmr_genes_mutated: List[str]      # e.g., ["MLH1", "MSH2"]
    dmmr_genes_checked: List[str]      # All genes checked
    method: str                         # "mutation_based" or "assay"
    confidence: float                   # 0.0 - 1.0

@dataclass
class HRDResult:
    status: HRDStatus
    score: Optional[float]              # If Myriad score available
    mechanism: Optional[str]            # e.g., "BRCA1_LOSS", "MBD4_BER"
    genes_mutated: List[str]            # HRR/BER genes mutated
    genes_checked: List[str]            # All genes checked
    confidence: float

@dataclass
class BiomarkerProfile:
    patient_id: str
    tmb: TMBResult
    msi: MSIResult
    hrd: HRDResult
    io_eligible: bool                   # TMB-H OR MSI-H
    io_eligibility_reason: str          # "TMB-H (12.3 mut/Mb)"
    parp_eligible: bool                 # HRD+ or BRCA mutant
    parp_eligibility_reason: str
    calculation_timestamp: datetime
    provenance: Dict[str, any]          # Full audit trail
```

---

## ðŸ—ï¸ IMPLEMENTATION

### File Structure

```
api/services/biomarkers/
â”œâ”€â”€ __init__.py
â”œâ”€â”€ biomarker_agent.py          # Main agent
â”œâ”€â”€ tmb_calculator.py           # TMB logic (port from validated)
â”œâ”€â”€ msi_detector.py             # MSI detection
â”œâ”€â”€ hrd_inferrer.py             # HRD inference
â”œâ”€â”€ io_eligibility.py           # IO eligibility determination
â”œâ”€â”€ constants.py                # Gene lists, thresholds
â””â”€â”€ tests/
    â”œâ”€â”€ test_tmb.py
    â”œâ”€â”€ test_msi.py
    â”œâ”€â”€ test_hrd.py
    â””â”€â”€ test_io_eligibility.py
```

### Core Agent Implementation

```python
# api/services/biomarkers/biomarker_agent.py

from typing import List
from datetime import datetime
import logging

from .tmb_calculator import TMBCalculator
from .msi_detector import MSIDetector
from .hrd_inferrer import HRDInferrer
from .io_eligibility import IOEligibilityChecker
from ..models import PatientProfile, BiomarkerProfile

logger = logging.getLogger(__name__)

class BiomarkerAgent:
    """
    Calculate all biomarkers from patient mutation data.
    
    Capabilities:
    - TMB (validated r=0.933 vs TCGA)
    - MSI (dMMR gene-based detection)
    - HRD (HRR/BER gene inference)
    - IO eligibility (TMB-H OR MSI-H)
    """
    
    def __init__(self):
        self.tmb_calculator = TMBCalculator()
        self.msi_detector = MSIDetector()
        self.hrd_inferrer = HRDInferrer()
        self.io_checker = IOEligibilityChecker()
    
    async def calculate(
        self,
        patient_profile: PatientProfile,
        options: dict = None
    ) -> BiomarkerProfile:
        """
        Calculate all biomarkers for a patient.
        
        Args:
            patient_profile: Patient data with mutations
            options: Optional config (thresholds, etc.)
        
        Returns:
            BiomarkerProfile with all calculated values
        """
        logger.info(f"Calculating biomarkers for {patient_profile.patient_id}")
        
        # Convert mutations to dict format for calculators
        mutations = self._mutations_to_dicts(patient_profile.mutations)
        
        # Step 1: Calculate TMB
        tmb_result = self.tmb_calculator.calculate(
            mutations=mutations,
            exome_size_mb=options.get('exome_size_mb', 38.0) if options else 38.0,
            threshold=options.get('tmb_threshold', 10.0) if options else 10.0
        )
        
        # Step 2: Detect MSI
        msi_result = self.msi_detector.detect(
            mutations=mutations,
            germline=patient_profile.germline_panel
        )
        
        # Step 3: Infer HRD
        hrd_result = self.hrd_inferrer.infer(
            mutations=mutations,
            germline=patient_profile.germline_panel,
            myriad_score=options.get('myriad_hrd_score') if options else None
        )
        
        # Step 4: Determine IO eligibility
        io_eligible, io_reason = self.io_checker.check(
            tmb_result=tmb_result,
            msi_result=msi_result
        )
        
        # Step 5: Determine PARP eligibility
        parp_eligible, parp_reason = self._check_parp_eligibility(hrd_result)
        
        # Build profile
        profile = BiomarkerProfile(
            patient_id=patient_profile.patient_id,
            tmb=tmb_result,
            msi=msi_result,
            hrd=hrd_result,
            io_eligible=io_eligible,
            io_eligibility_reason=io_reason,
            parp_eligible=parp_eligible,
            parp_eligibility_reason=parp_reason,
            calculation_timestamp=datetime.utcnow(),
            provenance={
                'tmb_validation': 'TCGA Pan-Immune r=0.933, n=1895',
                'msi_method': 'dMMR gene mutation detection',
                'hrd_method': 'HRR/BER gene inference'
            }
        )
        
        logger.info(
            f"Biomarkers: TMB={tmb_result.value:.2f}, "
            f"MSI={msi_result.status.value}, "
            f"HRD={hrd_result.status.value}, "
            f"IO={io_eligible}"
        )
        
        return profile
    
    def _mutations_to_dicts(self, mutations: List) -> List[dict]:
        """Convert Mutation objects to dicts for calculators."""
        return [
            {
                'gene': m.gene,
                'variant': m.variant,
                'hgvs_p': m.hgvs_p,
                'hgvs_c': m.hgvs_c,
                'variant_classification': m.classification,
                'protein_change': m.hgvs_p
            }
            for m in mutations
        ]
    
    def _check_parp_eligibility(self, hrd_result: HRDResult) -> tuple:
        """Check PARP inhibitor eligibility."""
        if hrd_result.status in [HRDStatus.HRD_POSITIVE, HRDStatus.HRD_INFERRED]:
            reason = f"{hrd_result.status.value}"
            if hrd_result.mechanism:
                reason += f" ({hrd_result.mechanism})"
            return True, reason
        
        return False, "HRD not detected"
```

### TMB Calculator

```python
# api/services/biomarkers/tmb_calculator.py

from typing import List, Dict
from dataclasses import dataclass
from .constants import NONSYNONYMOUS_CLASSIFICATIONS, TCGA_EXOME_SIZE_MB

@dataclass
class TMBResult:
    value: float
    classification: str
    threshold_used: float
    mutation_count: int
    exome_size_mb: float
    validation: Dict[str, any]

class TMBCalculator:
    """
    Calculate Tumor Mutational Burden.
    
    Validated against TCGA Pan-Immune publication:
    - Pearson r = 0.933
    - Classification accuracy = 95.4%
    """
    
    def calculate(
        self,
        mutations: List[Dict],
        exome_size_mb: float = TCGA_EXOME_SIZE_MB,
        threshold: float = 10.0
    ) -> TMBResult:
        """
        Calculate TMB from mutation list.
        
        Args:
            mutations: List of mutation dicts with variant_classification
            exome_size_mb: Exome size in megabases (default: 38.0)
            threshold: TMB-H threshold (default: 10.0 mut/Mb)
        
        Returns:
            TMBResult with value and classification
        """
        # Count nonsynonymous mutations
        count = self._count_nonsynonymous(mutations)
        
        # Calculate TMB
        tmb_value = count / exome_size_mb if exome_size_mb > 0 else 0.0
        
        # Classify
        classification = "TMB-H" if tmb_value >= threshold else "TMB-L"
        
        return TMBResult(
            value=round(tmb_value, 2),
            classification=classification,
            threshold_used=threshold,
            mutation_count=count,
            exome_size_mb=exome_size_mb,
            validation={
                'method': 'nonsynonymous_count / exome_size',
                'ground_truth': 'TCGA Pan-Immune',
                'pearson_r': 0.933,
                'accuracy': 0.954,
                'n_validated': 1895
            }
        )
    
    def _count_nonsynonymous(self, mutations: List[Dict]) -> int:
        """Count nonsynonymous mutations."""
        count = 0
        for mut in mutations:
            classification = mut.get("variant_classification", "").strip()
            protein_change = mut.get("hgvs_p", "") or mut.get("protein_change", "")
            
            # Check standard MAF classifications
            if classification in NONSYNONYMOUS_CLASSIFICATIONS:
                count += 1
                continue
            
            # Handle simplified classifications (SNP, DEL, INS)
            if protein_change and protein_change.strip():
                if "=" in protein_change or protein_change.endswith("="):
                    continue  # Silent mutation
                if classification.upper() in ["SNP", "DEL", "INS", "ONP"]:
                    count += 1
        
        return count
```

### MSI Detector

```python
# api/services/biomarkers/msi_detector.py

from typing import List, Dict, Optional
from dataclasses import dataclass
from .constants import DMMR_GENES

@dataclass
class MSIResult:
    status: str
    dmmr_genes_mutated: List[str]
    dmmr_genes_checked: List[str]
    method: str
    confidence: float

class MSIDetector:
    """
    Detect Microsatellite Instability from dMMR gene mutations.
    
    dMMR genes: MLH1, MSH2, MSH6, PMS2, EPCAM
    """
    
    def detect(
        self,
        mutations: List[Dict],
        germline: Optional[dict] = None
    ) -> MSIResult:
        """
        Detect MSI status from dMMR gene mutations.
        
        Args:
            mutations: Somatic mutations
            germline: Optional germline panel results
        
        Returns:
            MSIResult with status and details
        """
        # Get mutated genes
        mutated_genes = {m.get('gene', '').upper() for m in mutations}
        
        # Check dMMR genes
        dmmr_mutated = []
        for gene in DMMR_GENES:
            if gene in mutated_genes:
                dmmr_mutated.append(gene)
        
        # Also check germline if available
        if germline and hasattr(germline, 'pathogenic'):
            for gene in DMMR_GENES:
                if gene in germline.pathogenic:
                    if gene not in dmmr_mutated:
                        dmmr_mutated.append(gene)
        
        # Determine status
        if len(dmmr_mutated) >= 1:
            status = "MSI-H"
            confidence = 0.85 if len(dmmr_mutated) >= 2 else 0.70
        else:
            status = "MSS"
            confidence = 0.80  # Lower confidence without assay
        
        return MSIResult(
            status=status,
            dmmr_genes_mutated=dmmr_mutated,
            dmmr_genes_checked=list(DMMR_GENES),
            method="mutation_based",
            confidence=confidence
        )
```

### HRD Inferrer

```python
# api/services/biomarkers/hrd_inferrer.py

from typing import List, Dict, Optional
from dataclasses import dataclass
from .constants import HRR_GENES, BER_GENES

@dataclass
class HRDResult:
    status: str
    score: Optional[float]
    mechanism: Optional[str]
    genes_mutated: List[str]
    genes_checked: List[str]
    confidence: float

class HRDInferrer:
    """
    Infer Homologous Recombination Deficiency from DNA repair gene mutations.
    
    HRR genes: BRCA1, BRCA2, ATM, ATR, CHEK1, CHEK2, RAD51C, RAD51D, PALB2, BARD1
    BER genes: MBD4, MUTYH, OGG1, NTHL1, NEIL1
    """
    
    def infer(
        self,
        mutations: List[Dict],
        germline: Optional[dict] = None,
        myriad_score: Optional[float] = None
    ) -> HRDResult:
        """
        Infer HRD status from DNA repair gene mutations.
        
        Args:
            mutations: Somatic mutations
            germline: Optional germline panel
            myriad_score: Optional Myriad HRD score (â‰¥42 = HRD+)
        
        Returns:
            HRDResult with status and mechanism
        """
        # If we have Myriad score, use it directly
        if myriad_score is not None:
            status = "HRD+" if myriad_score >= 42 else "HRD-"
            return HRDResult(
                status=status,
                score=myriad_score,
                mechanism="myriad_score",
                genes_mutated=[],
                genes_checked=list(HRR_GENES | BER_GENES),
                confidence=0.95
            )
        
        # Otherwise, infer from mutations
        mutated_genes = {m.get('gene', '').upper() for m in mutations}
        
        # Check HRR genes
        hrr_mutated = [g for g in HRR_GENES if g in mutated_genes]
        
        # Check BER genes
        ber_mutated = [g for g in BER_GENES if g in mutated_genes]
        
        # Check germline
        if germline and hasattr(germline, 'pathogenic'):
            for gene in HRR_GENES | BER_GENES:
                if gene in germline.pathogenic:
                    if gene in HRR_GENES and gene not in hrr_mutated:
                        hrr_mutated.append(gene)
                    if gene in BER_GENES and gene not in ber_mutated:
                        ber_mutated.append(gene)
        
        # Determine status and mechanism
        all_mutated = hrr_mutated + ber_mutated
        
        if 'BRCA1' in all_mutated or 'BRCA2' in all_mutated:
            status = "HRD-INFERRED"
            mechanism = "BRCA_MUTATION"
            confidence = 0.90
        elif hrr_mutated:
            status = "HRD-INFERRED"
            mechanism = f"HRR_MUTATION_{hrr_mutated[0]}"
            confidence = 0.75
        elif ber_mutated:
            status = "HRD-INFERRED"
            mechanism = f"BER_DEFICIENCY_{ber_mutated[0]}"
            confidence = 0.70
        else:
            status = "unknown"
            mechanism = None
            confidence = 0.50
        
        return HRDResult(
            status=status,
            score=None,
            mechanism=mechanism,
            genes_mutated=all_mutated,
            genes_checked=list(HRR_GENES | BER_GENES),
            confidence=confidence
        )
```

### Constants

```python
# api/services/biomarkers/constants.py

# TMB Constants
TCGA_EXOME_SIZE_MB = 38.0
TMB_HIGH_THRESHOLD_PRIMARY = 10.0
TMB_HIGH_THRESHOLD_SECONDARY = 20.0

# Nonsynonymous mutation classifications
NONSYNONYMOUS_CLASSIFICATIONS = {
    'Missense_Mutation',
    'Nonsense_Mutation',
    'Frame_Shift_Del',
    'Frame_Shift_Ins',
    'In_Frame_Del',
    'In_Frame_Ins',
    'Splice_Site',
    'Translation_Start_Site',
    'Nonstop_Mutation'
}

# dMMR genes for MSI detection
DMMR_GENES = {'MLH1', 'MSH2', 'MSH6', 'PMS2', 'EPCAM'}

# Homologous Recombination Repair genes
HRR_GENES = {
    'BRCA1', 'BRCA2', 'ATM', 'ATR', 
    'CHEK1', 'CHEK2', 'RAD51C', 'RAD51D', 
    'PALB2', 'BARD1', 'BRIP1', 'FANCA', 
    'FANCD2', 'NBN', 'RAD51B'
}

# Base Excision Repair genes
BER_GENES = {
    'MBD4', 'MUTYH', 'OGG1', 'NTHL1', 
    'NEIL1', 'NEIL2', 'NEIL3', 'APEX1', 
    'XRCC1', 'PARP1', 'PARP2'
}
```

---

## ðŸ§ª TESTING

### TMB Validation Test

```python
# api/services/biomarkers/tests/test_tmb.py

import pytest
from ..tmb_calculator import TMBCalculator

@pytest.fixture
def calculator():
    return TMBCalculator()

def test_tmb_calculation_basic(calculator):
    mutations = [
        {'variant_classification': 'Missense_Mutation'},
        {'variant_classification': 'Missense_Mutation'},
        {'variant_classification': 'Frame_Shift_Del'},
    ]
    
    result = calculator.calculate(mutations, exome_size_mb=38.0)
    
    assert result.mutation_count == 3
    assert result.value == pytest.approx(3/38.0, rel=0.01)
    assert result.classification == "TMB-L"

def test_tmb_high_classification(calculator):
    # 380 mutations / 38 Mb = 10 mut/Mb = TMB-H
    mutations = [{'variant_classification': 'Missense_Mutation'}] * 380
    
    result = calculator.calculate(mutations)
    
    assert result.classification == "TMB-H"
    assert result.value >= 10.0

def test_tmb_skips_silent(calculator):
    mutations = [
        {'variant_classification': 'Missense_Mutation'},
        {'variant_classification': 'Silent'},  # Should be skipped
    ]
    
    result = calculator.calculate(mutations)
    
    assert result.mutation_count == 1
```

---

## ðŸ“‹ IMPLEMENTATION CHECKLIST

### Phase 1: TMB Calculator
- [ ] Port validated TMB code from `scripts/data_acquisition/utils/tmb_calculator.py`
- [ ] Add TMBResult dataclass
- [ ] Add validation provenance
- [ ] Unit tests matching TCGA validation

### Phase 2: MSI Detector
- [ ] Implement dMMR gene checking
- [ ] Handle germline results
- [ ] Add confidence scoring
- [ ] Unit tests

### Phase 3: HRD Inferrer
- [ ] Implement HRR gene checking
- [ ] Implement BER gene checking (MBD4)
- [ ] Support Myriad score input
- [ ] Mechanism identification
- [ ] Unit tests

### Phase 4: Integration
- [ ] Create BiomarkerAgent class
- [ ] Wire all calculators
- [ ] Add IO eligibility logic
- [ ] Add PARP eligibility logic
- [ ] Integration tests

---

## ðŸ“¡ API ENDPOINT

```yaml
POST /api/agents/biomarkers
Content-Type: application/json

Request:
  patient_id: string
  mutations: Mutation[]
  options:
    exome_size_mb: number  # default: 38.0
    tmb_threshold: number  # default: 10.0
    myriad_hrd_score: number  # optional

Response:
  biomarker_profile: BiomarkerProfile
  calculation_time_ms: number
```

---

## âœ… ACCEPTANCE CRITERIA

1. âœ… TMB calculation matches validated r=0.933 against TCGA
2. âœ… TMB-H classification at â‰¥10 mut/Mb
3. âœ… MSI detection from dMMR gene mutations
4. âœ… HRD inference from HRR/BER gene mutations
5. âœ… IO eligibility = TMB-H OR MSI-H
6. âœ… PARP eligibility = HRD+ or BRCA mutant
7. âœ… All results include validation provenance
8. âœ… Unit test coverage >80%

---