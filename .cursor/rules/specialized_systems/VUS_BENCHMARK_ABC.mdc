# VUS Benchmark (A/B/C) — Reusable Harness + Truth Guarantees (MOAT)

## Purpose
Prove the platform can **resolve VUS dynamically** (no hardcoding) by running real calls through:
- `POST /api/vus/identify` (single-call orchestration)
- Which internally calls: Ensembl VEP (HGVS→coords), ClinVar prior, Evo2 delta via `/api/evo/score_variant_multi`, Insights bundle, and Fusion coverage gate.

This is the “40% VUS” operational proof harness.

## What “dynamic” means (and what it does NOT mean)
- **Dynamic (YES)**: any variant that can be represented as **HGVS coding** or **GRCh38 SNV coords** can be normalized and triaged.
- **Not yet universal (NO)**: complex indels/CNV/SVs, transcript-specific edge cases, and deep intronic/structural variants are not fully covered by this harness.

## A/B/C Scenarios (labels are computed by the benchmark)
- **A — ML-resolved**: `resolution_path=evo2` (non-decisive prior; Evo2 + insights resolve).
- **B — Known driver**: `resolution_path=prior` AND `pathway_context.pathway_relevance=high` (prior is decisive AND it aligns with patient axis).
- **C — “VUS prior, damaging ML”**: ClinVar non-decisive (VUS/conflicting/missing) AND ML verdict is **damaging** → escalate.

## Command: Run benchmark (local)
From `oncology-coPilot/oncology-backend-minimal/`:

```bash
python3 scripts/vus/benchmark_vus_identify.py --base-url http://127.0.0.1:8000 --mode discover --top-n 5
```

This writes artifacts into:
- `results/vus_bench/<timestamp>/run_manifest.json`
- `results/vus_bench/<timestamp>/report.json`
- `results/vus_bench/<timestamp>/<case>.json` receipts (per-variant)

## Expected outputs (receipts)
`run_manifest.json` includes per-case:
- `scenario`: `"A"|"B"|"C"|"-"`
- `resolution_path`: `"prior"|"evo2"|null`
- `triage_verdict`
- `min_delta` (nullable — null means “not scoreable” or Evo unavailable)
- `clinvar` label (CoverageChips compatible)
- `pathway_relevance` (high/low/unknown)

## Truth guarantees / non-negotiables
- **No silent near-zero deltas**:
  - If upstream rejects REF allele (Ensembl mismatch), Evo returns `min_delta: null` with provenance fallback `ref_mismatch`.
- **No forced evo2_7b**:
  - Backend defaults to `DEFAULT_EVO_MODEL` (usually `evo2_1b`) for stability.
  - `insights.py` must never hardcode `evo2_7b` as a default.

## Key code anchors
- Benchmark harness: `scripts/vus/benchmark_vus_identify.py`
- VUS endpoint: `api/routers/vus.py`
- Evo proxy (fallbacks + mismatch handling): `api/routers/evo.py`
- Insights defaults (must not force 7B): `api/routers/insights.py`
- Evo URLs: `api/config.py`

## Known operational gotchas
- If you see log calls to a dead 7B URL (`evoservice7b ... 404`), you likely have:
  - `insights.py` defaulting `model_id="evo2_7b"` (bug), or
  - env var `EVO_URL_7B` set to a non-deployed URL.
  Fix: set defaults to `DEFAULT_EVO_MODEL` and/or unset `EVO_URL_7B`.


- `POST /api/vus/identify` (single-call orchestration)
- Which internally calls: Ensembl VEP (HGVS→coords), ClinVar prior, Evo2 delta via `/api/evo/score_variant_multi`, Insights bundle, and Fusion coverage gate.

This is the “40% VUS” operational proof harness.

## What “dynamic” means (and what it does NOT mean)
- **Dynamic (YES)**: any variant that can be represented as **HGVS coding** or **GRCh38 SNV coords** can be normalized and triaged.
- **Not yet universal (NO)**: complex indels/CNV/SVs, transcript-specific edge cases, and deep intronic/structural variants are not fully covered by this harness.

## A/B/C Scenarios (labels are computed by the benchmark)
- **A — ML-resolved**: `resolution_path=evo2` (non-decisive prior; Evo2 + insights resolve).
- **B — Known driver**: `resolution_path=prior` AND `pathway_context.pathway_relevance=high` (prior is decisive AND it aligns with patient axis).
- **C — “VUS prior, damaging ML”**: ClinVar non-decisive (VUS/conflicting/missing) AND ML verdict is **damaging** → escalate.

## Command: Run benchmark (local)
From `oncology-coPilot/oncology-backend-minimal/`:

```bash
python3 scripts/vus/benchmark_vus_identify.py --base-url http://127.0.0.1:8000 --mode discover --top-n 5
```

This writes artifacts into:
- `results/vus_bench/<timestamp>/run_manifest.json`
- `results/vus_bench/<timestamp>/report.json`
- `results/vus_bench/<timestamp>/<case>.json` receipts (per-variant)

## Expected outputs (receipts)
`run_manifest.json` includes per-case:
- `scenario`: `"A"|"B"|"C"|"-"`
- `resolution_path`: `"prior"|"evo2"|null`
- `triage_verdict`
- `min_delta` (nullable — null means “not scoreable” or Evo unavailable)
- `clinvar` label (CoverageChips compatible)
- `pathway_relevance` (high/low/unknown)

## Truth guarantees / non-negotiables
- **No silent near-zero deltas**:
  - If upstream rejects REF allele (Ensembl mismatch), Evo returns `min_delta: null` with provenance fallback `ref_mismatch`.
- **No forced evo2_7b**:
  - Backend defaults to `DEFAULT_EVO_MODEL` (usually `evo2_1b`) for stability.
  - `insights.py` must never hardcode `evo2_7b` as a default.

## Key code anchors
- Benchmark harness: `scripts/vus/benchmark_vus_identify.py`
- VUS endpoint: `api/routers/vus.py`
- Evo proxy (fallbacks + mismatch handling): `api/routers/evo.py`
- Insights defaults (must not force 7B): `api/routers/insights.py`
- Evo URLs: `api/config.py`

## Known operational gotchas
- If you see log calls to a dead 7B URL (`evoservice7b ... 404`), you likely have:
  - `insights.py` defaulting `model_id="evo2_7b"` (bug), or
  - env var `EVO_URL_7B` set to a non-deployed URL.
  Fix: set defaults to `DEFAULT_EVO_MODEL` and/or unset `EVO_URL_7B`.

